<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultShader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">gdx</a> &gt; <a href="index.source.html" class="el_package">com.badlogic.gdx.graphics.g3d.shaders</a> &gt; <span class="el_source">DefaultShader.java</span></div><h1>DefaultShader.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2011 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

package com.badlogic.gdx.graphics.g3d.shaders;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Camera;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.VertexAttribute;
import com.badlogic.gdx.graphics.VertexAttributes.Usage;
import com.badlogic.gdx.graphics.g3d.Attribute;
import com.badlogic.gdx.graphics.g3d.Attributes;
import com.badlogic.gdx.graphics.g3d.Environment;
import com.badlogic.gdx.graphics.g3d.Renderable;
import com.badlogic.gdx.graphics.g3d.Shader;
import com.badlogic.gdx.graphics.g3d.attributes.BlendingAttribute;
import com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute;
import com.badlogic.gdx.graphics.g3d.attributes.CubemapAttribute;
import com.badlogic.gdx.graphics.g3d.attributes.DepthTestAttribute;
import com.badlogic.gdx.graphics.g3d.attributes.DirectionalLightsAttribute;
import com.badlogic.gdx.graphics.g3d.attributes.FloatAttribute;
import com.badlogic.gdx.graphics.g3d.attributes.IntAttribute;
import com.badlogic.gdx.graphics.g3d.attributes.PointLightsAttribute;
import com.badlogic.gdx.graphics.g3d.attributes.SpotLightsAttribute;
import com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute;
import com.badlogic.gdx.graphics.g3d.environment.AmbientCubemap;
import com.badlogic.gdx.graphics.g3d.environment.DirectionalLight;
import com.badlogic.gdx.graphics.g3d.environment.PointLight;
import com.badlogic.gdx.graphics.g3d.environment.SpotLight;
import com.badlogic.gdx.graphics.g3d.utils.RenderContext;
import com.badlogic.gdx.graphics.glutils.ShaderProgram;
import com.badlogic.gdx.math.Matrix3;
import com.badlogic.gdx.math.Matrix4;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.GdxRuntimeException;

public class DefaultShader extends BaseShader {
	public static class Config {
		/** The uber vertex shader to use, null to use the default vertex shader. */
<span class="nc" id="L54">		public String vertexShader = null;</span>
		/** The uber fragment shader to use, null to use the default fragment shader. */
<span class="nc" id="L56">		public String fragmentShader = null;</span>
		/** The number of directional lights to use */
<span class="nc" id="L58">		public int numDirectionalLights = 2;</span>
		/** The number of point lights to use */
<span class="nc" id="L60">		public int numPointLights = 5;</span>
		/** The number of spot lights to use */
<span class="nc" id="L62">		public int numSpotLights = 0;</span>
		/** The number of bones to use */
<span class="nc" id="L64">		public int numBones = 12;</span>
		/** */
<span class="nc" id="L66">		public boolean ignoreUnimplemented = true;</span>
		/** Set to 0 to disable culling, -1 to inherit from {@link DefaultShader#defaultCullFace} */
<span class="nc" id="L68">		public int defaultCullFace = -1;</span>
		/** Set to 0 to disable depth test, -1 to inherit from {@link DefaultShader#defaultDepthFunc} */
<span class="nc" id="L70">		public int defaultDepthFunc = -1;</span>

<span class="nc" id="L72">		public Config () {</span>
<span class="nc" id="L73">		}</span>

<span class="nc" id="L75">		public Config (final String vertexShader, final String fragmentShader) {</span>
<span class="nc" id="L76">			this.vertexShader = vertexShader;</span>
<span class="nc" id="L77">			this.fragmentShader = fragmentShader;</span>
<span class="nc" id="L78">		}</span>
	}

<span class="nc" id="L81">	public static class Inputs {</span>
<span class="nc" id="L82">		public final static Uniform projTrans = new Uniform(&quot;u_projTrans&quot;);</span>
<span class="nc" id="L83">		public final static Uniform viewTrans = new Uniform(&quot;u_viewTrans&quot;);</span>
<span class="nc" id="L84">		public final static Uniform projViewTrans = new Uniform(&quot;u_projViewTrans&quot;);</span>
<span class="nc" id="L85">		public final static Uniform cameraPosition = new Uniform(&quot;u_cameraPosition&quot;);</span>
<span class="nc" id="L86">		public final static Uniform cameraDirection = new Uniform(&quot;u_cameraDirection&quot;);</span>
<span class="nc" id="L87">		public final static Uniform cameraUp = new Uniform(&quot;u_cameraUp&quot;);</span>
<span class="nc" id="L88">		public final static Uniform cameraNearFar = new Uniform(&quot;u_cameraNearFar&quot;);</span>

<span class="nc" id="L90">		public final static Uniform worldTrans = new Uniform(&quot;u_worldTrans&quot;);</span>
<span class="nc" id="L91">		public final static Uniform viewWorldTrans = new Uniform(&quot;u_viewWorldTrans&quot;);</span>
<span class="nc" id="L92">		public final static Uniform projViewWorldTrans = new Uniform(&quot;u_projViewWorldTrans&quot;);</span>
<span class="nc" id="L93">		public final static Uniform normalMatrix = new Uniform(&quot;u_normalMatrix&quot;);</span>
<span class="nc" id="L94">		public final static Uniform bones = new Uniform(&quot;u_bones&quot;);</span>

<span class="nc" id="L96">		public final static Uniform shininess = new Uniform(&quot;u_shininess&quot;, FloatAttribute.Shininess);</span>
<span class="nc" id="L97">		public final static Uniform opacity = new Uniform(&quot;u_opacity&quot;, BlendingAttribute.Type);</span>
<span class="nc" id="L98">		public final static Uniform diffuseColor = new Uniform(&quot;u_diffuseColor&quot;, ColorAttribute.Diffuse);</span>
<span class="nc" id="L99">		public final static Uniform diffuseTexture = new Uniform(&quot;u_diffuseTexture&quot;, TextureAttribute.Diffuse);</span>
<span class="nc" id="L100">		public final static Uniform diffuseUVTransform = new Uniform(&quot;u_diffuseUVTransform&quot;, TextureAttribute.Diffuse);</span>
<span class="nc" id="L101">		public final static Uniform specularColor = new Uniform(&quot;u_specularColor&quot;, ColorAttribute.Specular);</span>
<span class="nc" id="L102">		public final static Uniform specularTexture = new Uniform(&quot;u_specularTexture&quot;, TextureAttribute.Specular);</span>
<span class="nc" id="L103">		public final static Uniform specularUVTransform = new Uniform(&quot;u_specularUVTransform&quot;, TextureAttribute.Specular);</span>
<span class="nc" id="L104">		public final static Uniform emissiveColor = new Uniform(&quot;u_emissiveColor&quot;, ColorAttribute.Emissive);</span>
<span class="nc" id="L105">		public final static Uniform emissiveTexture = new Uniform(&quot;u_emissiveTexture&quot;, TextureAttribute.Emissive);</span>
<span class="nc" id="L106">		public final static Uniform emissiveUVTransform = new Uniform(&quot;u_emissiveUVTransform&quot;, TextureAttribute.Emissive);</span>
<span class="nc" id="L107">		public final static Uniform reflectionColor = new Uniform(&quot;u_reflectionColor&quot;, ColorAttribute.Reflection);</span>
<span class="nc" id="L108">		public final static Uniform reflectionTexture = new Uniform(&quot;u_reflectionTexture&quot;, TextureAttribute.Reflection);</span>
<span class="nc" id="L109">		public final static Uniform reflectionUVTransform = new Uniform(&quot;u_reflectionUVTransform&quot;, TextureAttribute.Reflection);</span>
<span class="nc" id="L110">		public final static Uniform normalTexture = new Uniform(&quot;u_normalTexture&quot;, TextureAttribute.Normal);</span>
<span class="nc" id="L111">		public final static Uniform normalUVTransform = new Uniform(&quot;u_normalUVTransform&quot;, TextureAttribute.Normal);</span>
<span class="nc" id="L112">		public final static Uniform ambientTexture = new Uniform(&quot;u_ambientTexture&quot;, TextureAttribute.Ambient);</span>
<span class="nc" id="L113">		public final static Uniform ambientUVTransform = new Uniform(&quot;u_ambientUVTransform&quot;, TextureAttribute.Ambient);</span>
<span class="nc" id="L114">		public final static Uniform alphaTest = new Uniform(&quot;u_alphaTest&quot;);</span>

<span class="nc" id="L116">		public final static Uniform ambientCube = new Uniform(&quot;u_ambientCubemap&quot;);</span>
<span class="nc" id="L117">		public final static Uniform dirLights = new Uniform(&quot;u_dirLights&quot;);</span>
<span class="nc" id="L118">		public final static Uniform pointLights = new Uniform(&quot;u_pointLights&quot;);</span>
<span class="nc" id="L119">		public final static Uniform spotLights = new Uniform(&quot;u_spotLights&quot;);</span>
<span class="nc" id="L120">		public final static Uniform environmentCubemap = new Uniform(&quot;u_environmentCubemap&quot;);</span>
	}

<span class="nc" id="L123">	public static class Setters {</span>
<span class="nc" id="L124">		public final static Setter projTrans = new GlobalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L127">				shader.set(inputID, shader.camera.projection);</span>
<span class="nc" id="L128">			}</span>
		};
<span class="nc" id="L130">		public final static Setter viewTrans = new GlobalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L133">				shader.set(inputID, shader.camera.view);</span>
<span class="nc" id="L134">			}</span>
		};
<span class="nc" id="L136">		public final static Setter projViewTrans = new GlobalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L139">				shader.set(inputID, shader.camera.combined);</span>
<span class="nc" id="L140">			}</span>
		};
<span class="nc" id="L142">		public final static Setter cameraPosition = new GlobalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L145">				shader.set(inputID, shader.camera.position.x, shader.camera.position.y, shader.camera.position.z,</span>
					1.1881f / (shader.camera.far * shader.camera.far));
<span class="nc" id="L147">			}</span>
		};
<span class="nc" id="L149">		public final static Setter cameraDirection = new GlobalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L152">				shader.set(inputID, shader.camera.direction);</span>
<span class="nc" id="L153">			}</span>
		};
<span class="nc" id="L155">		public final static Setter cameraUp = new GlobalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L158">				shader.set(inputID, shader.camera.up);</span>
<span class="nc" id="L159">			}</span>
		};
<span class="nc" id="L161">		public final static Setter cameraNearFar = new GlobalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L164">				shader.set(inputID, shader.camera.near, shader.camera.far);</span>
<span class="nc" id="L165">			}</span>
		};
<span class="nc" id="L167">		public final static Setter worldTrans = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L170">				shader.set(inputID, renderable.worldTransform);</span>
<span class="nc" id="L171">			}</span>
		};
<span class="nc" id="L173">		public final static Setter viewWorldTrans = new LocalSetter() {</span>
<span class="nc" id="L174">			final Matrix4 temp = new Matrix4();</span>

			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L178">				shader.set(inputID, temp.set(shader.camera.view).mul(renderable.worldTransform));</span>
<span class="nc" id="L179">			}</span>
		};
<span class="nc" id="L181">		public final static Setter projViewWorldTrans = new LocalSetter() {</span>
<span class="nc" id="L182">			final Matrix4 temp = new Matrix4();</span>

			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L186">				shader.set(inputID, temp.set(shader.camera.combined).mul(renderable.worldTransform));</span>
<span class="nc" id="L187">			}</span>
		};
<span class="nc" id="L189">		public final static Setter normalMatrix = new LocalSetter() {</span>
<span class="nc" id="L190">			private final Matrix3 tmpM = new Matrix3();</span>

			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L194">				shader.set(inputID, tmpM.set(renderable.worldTransform).inv().transpose());</span>
<span class="nc" id="L195">			}</span>
		};

		public static class Bones extends LocalSetter {
<span class="nc" id="L199">			private final static Matrix4 idtMatrix = new Matrix4();</span>
			public final float bones[];

<span class="nc" id="L202">			public Bones (final int numBones) {</span>
<span class="nc" id="L203">				this.bones = new float[numBones * 16];</span>
<span class="nc" id="L204">			}</span>

			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc bnc" id="L208" title="All 2 branches missed.">				for (int i = 0; i &lt; bones.length; i++) {</span>
<span class="nc" id="L209">					final int idx = i / 16;</span>
<span class="nc bnc" id="L210" title="All 6 branches missed.">					bones[i] = (renderable.bones == null || idx &gt;= renderable.bones.length || renderable.bones[idx] == null) ? idtMatrix.val[i % 16]</span>
<span class="nc" id="L211">						: renderable.bones[idx].val[i % 16];</span>
				}
<span class="nc" id="L213">				shader.program.setUniformMatrix4fv(shader.loc(inputID), bones, 0, bones.length);</span>
<span class="nc" id="L214">			}</span>
		}

<span class="nc" id="L217">		public final static Setter shininess = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L220">				shader.set(inputID, ((FloatAttribute)(combinedAttributes.get(FloatAttribute.Shininess))).value);</span>
<span class="nc" id="L221">			}</span>
		};
<span class="nc" id="L223">		public final static Setter diffuseColor = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L226">				shader.set(inputID, ((ColorAttribute)(combinedAttributes.get(ColorAttribute.Diffuse))).color);</span>
<span class="nc" id="L227">			}</span>
		};
<span class="nc" id="L229">		public final static Setter diffuseTexture = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L232">				final int unit = shader.context.textureBinder.bind(((TextureAttribute)(combinedAttributes</span>
<span class="nc" id="L233">					.get(TextureAttribute.Diffuse))).textureDescription);</span>
<span class="nc" id="L234">				shader.set(inputID, unit);</span>
<span class="nc" id="L235">			}</span>
		};
<span class="nc" id="L237">		public final static Setter diffuseUVTransform = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L240">				final TextureAttribute ta = (TextureAttribute)(combinedAttributes.get(TextureAttribute.Diffuse));</span>
<span class="nc" id="L241">				shader.set(inputID, ta.offsetU, ta.offsetV, ta.scaleU, ta.scaleV);</span>
<span class="nc" id="L242">			}</span>
		};
<span class="nc" id="L244">		public final static Setter specularColor = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L247">				shader.set(inputID, ((ColorAttribute)(combinedAttributes.get(ColorAttribute.Specular))).color);</span>
<span class="nc" id="L248">			}</span>
		};
<span class="nc" id="L250">		public final static Setter specularTexture = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L253">				final int unit = shader.context.textureBinder.bind(((TextureAttribute)(combinedAttributes</span>
<span class="nc" id="L254">					.get(TextureAttribute.Specular))).textureDescription);</span>
<span class="nc" id="L255">				shader.set(inputID, unit);</span>
<span class="nc" id="L256">			}</span>
		};
<span class="nc" id="L258">		public final static Setter specularUVTransform = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L261">				final TextureAttribute ta = (TextureAttribute)(combinedAttributes.get(TextureAttribute.Specular));</span>
<span class="nc" id="L262">				shader.set(inputID, ta.offsetU, ta.offsetV, ta.scaleU, ta.scaleV);</span>
<span class="nc" id="L263">			}</span>
		};
<span class="nc" id="L265">		public final static Setter emissiveColor = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L268">				shader.set(inputID, ((ColorAttribute)(combinedAttributes.get(ColorAttribute.Emissive))).color);</span>
<span class="nc" id="L269">			}</span>
		};
<span class="nc" id="L271">		public final static Setter emissiveTexture = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L274">				final int unit = shader.context.textureBinder.bind(((TextureAttribute)(combinedAttributes</span>
<span class="nc" id="L275">					.get(TextureAttribute.Emissive))).textureDescription);</span>
<span class="nc" id="L276">				shader.set(inputID, unit);</span>
<span class="nc" id="L277">			}</span>
		};
<span class="nc" id="L279">		public final static Setter emissiveUVTransform = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L282">				final TextureAttribute ta = (TextureAttribute)(combinedAttributes.get(TextureAttribute.Emissive));</span>
<span class="nc" id="L283">				shader.set(inputID, ta.offsetU, ta.offsetV, ta.scaleU, ta.scaleV);</span>
<span class="nc" id="L284">			}</span>
		};
<span class="nc" id="L286">		public final static Setter reflectionColor = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L289">				shader.set(inputID, ((ColorAttribute)(combinedAttributes.get(ColorAttribute.Reflection))).color);</span>
<span class="nc" id="L290">			}</span>
		};
<span class="nc" id="L292">		public final static Setter reflectionTexture = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L295">				final int unit = shader.context.textureBinder.bind(((TextureAttribute)(combinedAttributes</span>
<span class="nc" id="L296">					.get(TextureAttribute.Reflection))).textureDescription);</span>
<span class="nc" id="L297">				shader.set(inputID, unit);</span>
<span class="nc" id="L298">			}</span>
		};
<span class="nc" id="L300">		public final static Setter reflectionUVTransform = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L303">				final TextureAttribute ta = (TextureAttribute)(combinedAttributes.get(TextureAttribute.Reflection));</span>
<span class="nc" id="L304">				shader.set(inputID, ta.offsetU, ta.offsetV, ta.scaleU, ta.scaleV);</span>
<span class="nc" id="L305">			}</span>
		};
<span class="nc" id="L307">		public final static Setter normalTexture = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L310">				final int unit = shader.context.textureBinder.bind(((TextureAttribute)(combinedAttributes</span>
<span class="nc" id="L311">					.get(TextureAttribute.Normal))).textureDescription);</span>
<span class="nc" id="L312">				shader.set(inputID, unit);</span>
<span class="nc" id="L313">			}</span>
		};
<span class="nc" id="L315">		public final static Setter normalUVTransform = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L318">				final TextureAttribute ta = (TextureAttribute)(combinedAttributes.get(TextureAttribute.Normal));</span>
<span class="nc" id="L319">				shader.set(inputID, ta.offsetU, ta.offsetV, ta.scaleU, ta.scaleV);</span>
<span class="nc" id="L320">			}</span>
		};
<span class="nc" id="L322">		public final static Setter ambientTexture = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L325">				final int unit = shader.context.textureBinder.bind(((TextureAttribute)(combinedAttributes</span>
<span class="nc" id="L326">					.get(TextureAttribute.Ambient))).textureDescription);</span>
<span class="nc" id="L327">				shader.set(inputID, unit);</span>
<span class="nc" id="L328">			}</span>
		};
<span class="nc" id="L330">		public final static Setter ambientUVTransform = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L333">				final TextureAttribute ta = (TextureAttribute)(combinedAttributes.get(TextureAttribute.Ambient));</span>
<span class="nc" id="L334">				shader.set(inputID, ta.offsetU, ta.offsetV, ta.scaleU, ta.scaleV);</span>
<span class="nc" id="L335">			}</span>
		};

		public static class ACubemap extends LocalSetter {
<span class="nc" id="L339">			private final static float ones[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};</span>
<span class="nc" id="L340">			private final AmbientCubemap cacheAmbientCubemap = new AmbientCubemap();</span>
<span class="nc" id="L341">			private final static Vector3 tmpV1 = new Vector3();</span>
			public final int dirLightsOffset;
			public final int pointLightsOffset;

<span class="nc" id="L345">			public ACubemap (final int dirLightsOffset, final int pointLightsOffset) {</span>
<span class="nc" id="L346">				this.dirLightsOffset = dirLightsOffset;</span>
<span class="nc" id="L347">				this.pointLightsOffset = pointLightsOffset;</span>
<span class="nc" id="L348">			}</span>

			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc bnc" id="L352" title="All 2 branches missed.">				if (renderable.environment == null)</span>
<span class="nc" id="L353">					shader.program.setUniform3fv(shader.loc(inputID), ones, 0, ones.length);</span>
				else {
<span class="nc" id="L355">					renderable.worldTransform.getTranslation(tmpV1);</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">					if (combinedAttributes.has(ColorAttribute.AmbientLight))</span>
<span class="nc" id="L357">						cacheAmbientCubemap.set(((ColorAttribute)combinedAttributes.get(ColorAttribute.AmbientLight)).color);</span>

<span class="nc bnc" id="L359" title="All 2 branches missed.">					if (combinedAttributes.has(DirectionalLightsAttribute.Type)) {</span>
<span class="nc" id="L360">						Array&lt;DirectionalLight&gt; lights = ((DirectionalLightsAttribute)combinedAttributes</span>
<span class="nc" id="L361">							.get(DirectionalLightsAttribute.Type)).lights;</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">						for (int i = dirLightsOffset; i &lt; lights.size; i++)</span>
<span class="nc" id="L363">							cacheAmbientCubemap.add(lights.get(i).color, lights.get(i).direction);</span>
					}

<span class="nc bnc" id="L366" title="All 2 branches missed.">					if (combinedAttributes.has(PointLightsAttribute.Type)) {</span>
<span class="nc" id="L367">						Array&lt;PointLight&gt; lights = ((PointLightsAttribute)combinedAttributes.get(PointLightsAttribute.Type)).lights;</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">						for (int i = pointLightsOffset; i &lt; lights.size; i++)</span>
<span class="nc" id="L369">							cacheAmbientCubemap.add(lights.get(i).color, lights.get(i).position, tmpV1, lights.get(i).intensity);</span>
					}

<span class="nc" id="L372">					cacheAmbientCubemap.clamp();</span>
<span class="nc" id="L373">					shader.program.setUniform3fv(shader.loc(inputID), cacheAmbientCubemap.data, 0, cacheAmbientCubemap.data.length);</span>
				}
<span class="nc" id="L375">			}</span>
		}

<span class="nc" id="L378">		public final static Setter environmentCubemap = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc bnc" id="L381" title="All 2 branches missed.">				if (combinedAttributes.has(CubemapAttribute.EnvironmentMap)) {</span>
<span class="nc" id="L382">					shader.set(inputID, shader.context.textureBinder.bind(((CubemapAttribute)combinedAttributes</span>
<span class="nc" id="L383">						.get(CubemapAttribute.EnvironmentMap)).textureDescription));</span>
				}
<span class="nc" id="L385">			}</span>
		};
	}

<span class="nc" id="L389">	private static String defaultVertexShader = null;</span>

	public static String getDefaultVertexShader () {
<span class="nc bnc" id="L392" title="All 2 branches missed.">		if (defaultVertexShader == null)</span>
<span class="nc" id="L393">			defaultVertexShader = Gdx.files.classpath(&quot;com/badlogic/gdx/graphics/g3d/shaders/default.vertex.glsl&quot;).readString();</span>
<span class="nc" id="L394">		return defaultVertexShader;</span>
	}

<span class="nc" id="L397">	private static String defaultFragmentShader = null;</span>

	public static String getDefaultFragmentShader () {
<span class="nc bnc" id="L400" title="All 2 branches missed.">		if (defaultFragmentShader == null)</span>
<span class="nc" id="L401">			defaultFragmentShader = Gdx.files.classpath(&quot;com/badlogic/gdx/graphics/g3d/shaders/default.fragment.glsl&quot;).readString();</span>
<span class="nc" id="L402">		return defaultFragmentShader;</span>
	}

<span class="nc" id="L405">	protected static long implementedFlags = BlendingAttribute.Type | TextureAttribute.Diffuse | ColorAttribute.Diffuse</span>
		| ColorAttribute.Specular | FloatAttribute.Shininess;

	/** @deprecated Replaced by {@link Config#defaultCullFace} Set to 0 to disable culling */
<span class="nc" id="L409">	@Deprecated public static int defaultCullFace = GL20.GL_BACK;</span>
	/** @deprecated Replaced by {@link Config#defaultDepthFunc} Set to 0 to disable depth test */
<span class="nc" id="L411">	@Deprecated public static int defaultDepthFunc = GL20.GL_LEQUAL;</span>

	// Global uniforms
	public final int u_projTrans;
	public final int u_viewTrans;
	public final int u_projViewTrans;
	public final int u_cameraPosition;
	public final int u_cameraDirection;
	public final int u_cameraUp;
	public final int u_cameraNearFar;
	public final int u_time;
	// Object uniforms
	public final int u_worldTrans;
	public final int u_viewWorldTrans;
	public final int u_projViewWorldTrans;
	public final int u_normalMatrix;
	public final int u_bones;
	// Material uniforms
	public final int u_shininess;
	public final int u_opacity;
	public final int u_diffuseColor;
	public final int u_diffuseTexture;
	public final int u_diffuseUVTransform;
	public final int u_specularColor;
	public final int u_specularTexture;
	public final int u_specularUVTransform;
	public final int u_emissiveColor;
	public final int u_emissiveTexture;
	public final int u_emissiveUVTransform;
	public final int u_reflectionColor;
	public final int u_reflectionTexture;
	public final int u_reflectionUVTransform;
	public final int u_normalTexture;
	public final int u_normalUVTransform;
	public final int u_ambientTexture;
	public final int u_ambientUVTransform;
	public final int u_alphaTest;
	// Lighting uniforms
	protected final int u_ambientCubemap;
	protected final int u_environmentCubemap;
<span class="nc" id="L451">	protected final int u_dirLights0color = register(new Uniform(&quot;u_dirLights[0].color&quot;));</span>
<span class="nc" id="L452">	protected final int u_dirLights0direction = register(new Uniform(&quot;u_dirLights[0].direction&quot;));</span>
<span class="nc" id="L453">	protected final int u_dirLights1color = register(new Uniform(&quot;u_dirLights[1].color&quot;));</span>
<span class="nc" id="L454">	protected final int u_pointLights0color = register(new Uniform(&quot;u_pointLights[0].color&quot;));</span>
<span class="nc" id="L455">	protected final int u_pointLights0position = register(new Uniform(&quot;u_pointLights[0].position&quot;));</span>
<span class="nc" id="L456">	protected final int u_pointLights0intensity = register(new Uniform(&quot;u_pointLights[0].intensity&quot;));</span>
<span class="nc" id="L457">	protected final int u_pointLights1color = register(new Uniform(&quot;u_pointLights[1].color&quot;));</span>
<span class="nc" id="L458">	protected final int u_spotLights0color = register(new Uniform(&quot;u_spotLights[0].color&quot;));</span>
<span class="nc" id="L459">	protected final int u_spotLights0position = register(new Uniform(&quot;u_spotLights[0].position&quot;));</span>
<span class="nc" id="L460">	protected final int u_spotLights0intensity = register(new Uniform(&quot;u_spotLights[0].intensity&quot;));</span>
<span class="nc" id="L461">	protected final int u_spotLights0direction = register(new Uniform(&quot;u_spotLights[0].direction&quot;));</span>
<span class="nc" id="L462">	protected final int u_spotLights0cutoffAngle = register(new Uniform(&quot;u_spotLights[0].cutoffAngle&quot;));</span>
<span class="nc" id="L463">	protected final int u_spotLights0exponent = register(new Uniform(&quot;u_spotLights[0].exponent&quot;));</span>
<span class="nc" id="L464">	protected final int u_spotLights1color = register(new Uniform(&quot;u_spotLights[1].color&quot;));</span>
<span class="nc" id="L465">	protected final int u_fogColor = register(new Uniform(&quot;u_fogColor&quot;));</span>
<span class="nc" id="L466">	protected final int u_shadowMapProjViewTrans = register(new Uniform(&quot;u_shadowMapProjViewTrans&quot;));</span>
<span class="nc" id="L467">	protected final int u_shadowTexture = register(new Uniform(&quot;u_shadowTexture&quot;));</span>
<span class="nc" id="L468">	protected final int u_shadowPCFOffset = register(new Uniform(&quot;u_shadowPCFOffset&quot;));</span>
	// FIXME Cache vertex attribute locations...

	protected int dirLightsLoc;
	protected int dirLightsColorOffset;
	protected int dirLightsDirectionOffset;
	protected int dirLightsSize;
	protected int pointLightsLoc;
	protected int pointLightsColorOffset;
	protected int pointLightsPositionOffset;
	protected int pointLightsIntensityOffset;
	protected int pointLightsSize;
	protected int spotLightsLoc;
	protected int spotLightsColorOffset;
	protected int spotLightsPositionOffset;
	protected int spotLightsDirectionOffset;
	protected int spotLightsIntensityOffset;
	protected int spotLightsCutoffAngleOffset;
	protected int spotLightsExponentOffset;
	protected int spotLightsSize;

	protected final boolean lighting;
	protected final boolean environmentCubemap;
	protected final boolean shadowMap;
<span class="nc" id="L492">	protected final AmbientCubemap ambientCubemap = new AmbientCubemap();</span>
	protected final DirectionalLight directionalLights[];
	protected final PointLight pointLights[];
	protected final SpotLight spotLights[];

	/** The renderable used to create this shader, invalid after the call to init */
	private Renderable renderable;
	/** The attributes that this shader supports */
	protected final long attributesMask;
	private final long vertexMask;
	protected final Config config;
	/** Attributes which are not required but always supported. */
<span class="nc" id="L504">	private final static long optionalAttributes = IntAttribute.CullFace | DepthTestAttribute.Type;</span>

	public DefaultShader (final Renderable renderable) {
<span class="nc" id="L507">		this(renderable, new Config());</span>
<span class="nc" id="L508">	}</span>

	public DefaultShader (final Renderable renderable, final Config config) {
<span class="nc" id="L511">		this(renderable, config, createPrefix(renderable, config));</span>
<span class="nc" id="L512">	}</span>

	public DefaultShader (final Renderable renderable, final Config config, final String prefix) {
<span class="nc bnc" id="L515" title="All 2 branches missed.">		this(renderable, config, prefix, config.vertexShader != null ? config.vertexShader : getDefaultVertexShader(),</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">			config.fragmentShader != null ? config.fragmentShader : getDefaultFragmentShader());</span>
<span class="nc" id="L517">	}</span>

	public DefaultShader (final Renderable renderable, final Config config, final String prefix, final String vertexShader,
		final String fragmentShader) {
<span class="nc" id="L521">		this(renderable, config, new ShaderProgram(prefix + vertexShader, prefix + fragmentShader));</span>
<span class="nc" id="L522">	}</span>

<span class="nc" id="L524">	public DefaultShader (final Renderable renderable, final Config config, final ShaderProgram shaderProgram) {</span>
<span class="nc" id="L525">		final Attributes attributes = combineAttributes(renderable);</span>
<span class="nc" id="L526">		this.config = config;</span>
<span class="nc" id="L527">		this.program = shaderProgram;</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">		this.lighting = renderable.environment != null;</span>
<span class="nc bnc" id="L529" title="All 4 branches missed.">		this.environmentCubemap = attributes.has(CubemapAttribute.EnvironmentMap)</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">			|| (lighting &amp;&amp; attributes.has(CubemapAttribute.EnvironmentMap));</span>
<span class="nc bnc" id="L531" title="All 4 branches missed.">		this.shadowMap = lighting &amp;&amp; renderable.environment.shadowMap != null;</span>
<span class="nc" id="L532">		this.renderable = renderable;</span>
<span class="nc" id="L533">		attributesMask = attributes.getMask() | optionalAttributes;</span>
<span class="nc" id="L534">		vertexMask = renderable.meshPart.mesh.getVertexAttributes().getMaskWithSizePacked();</span>

<span class="nc bnc" id="L536" title="All 4 branches missed.">		this.directionalLights = new DirectionalLight[lighting &amp;&amp; config.numDirectionalLights &gt; 0 ? config.numDirectionalLights : 0];</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">		for (int i = 0; i &lt; directionalLights.length; i++)</span>
<span class="nc" id="L538">			directionalLights[i] = new DirectionalLight();</span>
<span class="nc bnc" id="L539" title="All 4 branches missed.">		this.pointLights = new PointLight[lighting &amp;&amp; config.numPointLights &gt; 0 ? config.numPointLights : 0];</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">		for (int i = 0; i &lt; pointLights.length; i++)</span>
<span class="nc" id="L541">			pointLights[i] = new PointLight();</span>
<span class="nc bnc" id="L542" title="All 4 branches missed.">		this.spotLights = new SpotLight[lighting &amp;&amp; config.numSpotLights &gt; 0 ? config.numSpotLights : 0];</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">		for (int i = 0; i &lt; spotLights.length; i++)</span>
<span class="nc" id="L544">			spotLights[i] = new SpotLight();</span>

<span class="nc bnc" id="L546" title="All 4 branches missed.">		if (!config.ignoreUnimplemented &amp;&amp; (implementedFlags &amp; attributesMask) != attributesMask)</span>
<span class="nc" id="L547">			throw new GdxRuntimeException(&quot;Some attributes not implemented yet (&quot; + attributesMask + &quot;)&quot;);</span>

		// Global uniforms
<span class="nc" id="L550">		u_projTrans = register(Inputs.projTrans, Setters.projTrans);</span>
<span class="nc" id="L551">		u_viewTrans = register(Inputs.viewTrans, Setters.viewTrans);</span>
<span class="nc" id="L552">		u_projViewTrans = register(Inputs.projViewTrans, Setters.projViewTrans);</span>
<span class="nc" id="L553">		u_cameraPosition = register(Inputs.cameraPosition, Setters.cameraPosition);</span>
<span class="nc" id="L554">		u_cameraDirection = register(Inputs.cameraDirection, Setters.cameraDirection);</span>
<span class="nc" id="L555">		u_cameraUp = register(Inputs.cameraUp, Setters.cameraUp);</span>
<span class="nc" id="L556">		u_cameraNearFar = register(Inputs.cameraNearFar, Setters.cameraNearFar);</span>
<span class="nc" id="L557">		u_time = register(new Uniform(&quot;u_time&quot;));</span>
		// Object uniforms
<span class="nc" id="L559">		u_worldTrans = register(Inputs.worldTrans, Setters.worldTrans);</span>
<span class="nc" id="L560">		u_viewWorldTrans = register(Inputs.viewWorldTrans, Setters.viewWorldTrans);</span>
<span class="nc" id="L561">		u_projViewWorldTrans = register(Inputs.projViewWorldTrans, Setters.projViewWorldTrans);</span>
<span class="nc" id="L562">		u_normalMatrix = register(Inputs.normalMatrix, Setters.normalMatrix);</span>
<span class="nc bnc" id="L563" title="All 4 branches missed.">		u_bones = (renderable.bones != null &amp;&amp; config.numBones &gt; 0) ? register(Inputs.bones, new Setters.Bones(config.numBones))</span>
<span class="nc" id="L564">			: -1;</span>

<span class="nc" id="L566">		u_shininess = register(Inputs.shininess, Setters.shininess);</span>
<span class="nc" id="L567">		u_opacity = register(Inputs.opacity);</span>
<span class="nc" id="L568">		u_diffuseColor = register(Inputs.diffuseColor, Setters.diffuseColor);</span>
<span class="nc" id="L569">		u_diffuseTexture = register(Inputs.diffuseTexture, Setters.diffuseTexture);</span>
<span class="nc" id="L570">		u_diffuseUVTransform = register(Inputs.diffuseUVTransform, Setters.diffuseUVTransform);</span>
<span class="nc" id="L571">		u_specularColor = register(Inputs.specularColor, Setters.specularColor);</span>
<span class="nc" id="L572">		u_specularTexture = register(Inputs.specularTexture, Setters.specularTexture);</span>
<span class="nc" id="L573">		u_specularUVTransform = register(Inputs.specularUVTransform, Setters.specularUVTransform);</span>
<span class="nc" id="L574">		u_emissiveColor = register(Inputs.emissiveColor, Setters.emissiveColor);</span>
<span class="nc" id="L575">		u_emissiveTexture = register(Inputs.emissiveTexture, Setters.emissiveTexture);</span>
<span class="nc" id="L576">		u_emissiveUVTransform = register(Inputs.emissiveUVTransform, Setters.emissiveUVTransform);</span>
<span class="nc" id="L577">		u_reflectionColor = register(Inputs.reflectionColor, Setters.reflectionColor);</span>
<span class="nc" id="L578">		u_reflectionTexture = register(Inputs.reflectionTexture, Setters.reflectionTexture);</span>
<span class="nc" id="L579">		u_reflectionUVTransform = register(Inputs.reflectionUVTransform, Setters.reflectionUVTransform);</span>
<span class="nc" id="L580">		u_normalTexture = register(Inputs.normalTexture, Setters.normalTexture);</span>
<span class="nc" id="L581">		u_normalUVTransform = register(Inputs.normalUVTransform, Setters.normalUVTransform);</span>
<span class="nc" id="L582">		u_ambientTexture = register(Inputs.ambientTexture, Setters.ambientTexture);</span>
<span class="nc" id="L583">		u_ambientUVTransform = register(Inputs.ambientUVTransform, Setters.ambientUVTransform);</span>
<span class="nc" id="L584">		u_alphaTest = register(Inputs.alphaTest);</span>

<span class="nc bnc" id="L586" title="All 2 branches missed.">		u_ambientCubemap = lighting ? register(Inputs.ambientCube, new Setters.ACubemap(config.numDirectionalLights,</span>
<span class="nc" id="L587">			config.numPointLights)) : -1;</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">		u_environmentCubemap = environmentCubemap ? register(Inputs.environmentCubemap, Setters.environmentCubemap) : -1;</span>
<span class="nc" id="L589">	}</span>

	@Override
	public void init () {
<span class="nc" id="L593">		final ShaderProgram program = this.program;</span>
<span class="nc" id="L594">		this.program = null;</span>
<span class="nc" id="L595">		init(program, renderable);</span>
<span class="nc" id="L596">		renderable = null;</span>

<span class="nc" id="L598">		dirLightsLoc = loc(u_dirLights0color);</span>
<span class="nc" id="L599">		dirLightsColorOffset = loc(u_dirLights0color) - dirLightsLoc;</span>
<span class="nc" id="L600">		dirLightsDirectionOffset = loc(u_dirLights0direction) - dirLightsLoc;</span>
<span class="nc" id="L601">		dirLightsSize = loc(u_dirLights1color) - dirLightsLoc;</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">		if (dirLightsSize &lt; 0) dirLightsSize = 0;</span>

<span class="nc" id="L604">		pointLightsLoc = loc(u_pointLights0color);</span>
<span class="nc" id="L605">		pointLightsColorOffset = loc(u_pointLights0color) - pointLightsLoc;</span>
<span class="nc" id="L606">		pointLightsPositionOffset = loc(u_pointLights0position) - pointLightsLoc;</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">		pointLightsIntensityOffset = has(u_pointLights0intensity) ? loc(u_pointLights0intensity) - pointLightsLoc : -1;</span>
<span class="nc" id="L608">		pointLightsSize = loc(u_pointLights1color) - pointLightsLoc;</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">		if (pointLightsSize &lt; 0) pointLightsSize = 0;</span>

<span class="nc" id="L611">		spotLightsLoc = loc(u_spotLights0color);</span>
<span class="nc" id="L612">		spotLightsColorOffset = loc(u_spotLights0color) - spotLightsLoc;</span>
<span class="nc" id="L613">		spotLightsPositionOffset = loc(u_spotLights0position) - spotLightsLoc;</span>
<span class="nc" id="L614">		spotLightsDirectionOffset = loc(u_spotLights0direction) - spotLightsLoc;</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">		spotLightsIntensityOffset = has(u_spotLights0intensity) ? loc(u_spotLights0intensity) - spotLightsLoc : -1;</span>
<span class="nc" id="L616">		spotLightsCutoffAngleOffset = loc(u_spotLights0cutoffAngle) - spotLightsLoc;</span>
<span class="nc" id="L617">		spotLightsExponentOffset = loc(u_spotLights0exponent) - spotLightsLoc;</span>
<span class="nc" id="L618">		spotLightsSize = loc(u_spotLights1color) - spotLightsLoc;</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">		if (spotLightsSize &lt; 0) spotLightsSize = 0;</span>
<span class="nc" id="L620">	}</span>

	private static final boolean and (final long mask, final long flag) {
<span class="nc bnc" id="L623" title="All 2 branches missed.">		return (mask &amp; flag) == flag;</span>
	}

	private static final boolean or (final long mask, final long flag) {
<span class="nc bnc" id="L627" title="All 2 branches missed.">		return (mask &amp; flag) != 0;</span>
	}

<span class="nc" id="L630">	private final static Attributes tmpAttributes = new Attributes();</span>

	// TODO: Perhaps move responsibility for combining attributes to RenderableProvider?
	private static final Attributes combineAttributes (final Renderable renderable) {
<span class="nc" id="L634">		tmpAttributes.clear();</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">		if (renderable.environment != null) tmpAttributes.set(renderable.environment);</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">		if (renderable.material != null) tmpAttributes.set(renderable.material);</span>
<span class="nc" id="L637">		return tmpAttributes;</span>
	}

	private static final long combineAttributeMasks (final Renderable renderable) {
<span class="nc" id="L641">		long mask = 0;</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">		if (renderable.environment != null) mask |= renderable.environment.getMask();</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">		if (renderable.material != null) mask |= renderable.material.getMask();</span>
<span class="nc" id="L644">		return mask;</span>
	}

	public static String createPrefix (final Renderable renderable, final Config config) {
<span class="nc" id="L648">		final Attributes attributes = combineAttributes(renderable);</span>
<span class="nc" id="L649">		String prefix = &quot;&quot;;</span>
<span class="nc" id="L650">		final long attributesMask = attributes.getMask();</span>
<span class="nc" id="L651">		final long vertexMask = renderable.meshPart.mesh.getVertexAttributes().getMask();</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">		if (and(vertexMask, Usage.Position)) prefix += &quot;#define positionFlag\n&quot;;</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">		if (or(vertexMask, Usage.ColorUnpacked | Usage.ColorPacked)) prefix += &quot;#define colorFlag\n&quot;;</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">		if (and(vertexMask, Usage.BiNormal)) prefix += &quot;#define binormalFlag\n&quot;;</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">		if (and(vertexMask, Usage.Tangent)) prefix += &quot;#define tangentFlag\n&quot;;</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">		if (and(vertexMask, Usage.Normal)) prefix += &quot;#define normalFlag\n&quot;;</span>
<span class="nc bnc" id="L657" title="All 4 branches missed.">		if (and(vertexMask, Usage.Normal) || and(vertexMask, Usage.Tangent | Usage.BiNormal)) {</span>
<span class="nc bnc" id="L658" title="All 2 branches missed.">			if (renderable.environment != null) {</span>
<span class="nc" id="L659">				prefix += &quot;#define lightingFlag\n&quot;;</span>
<span class="nc" id="L660">				prefix += &quot;#define ambientCubemapFlag\n&quot;;</span>
<span class="nc" id="L661">				prefix += &quot;#define numDirectionalLights &quot; + config.numDirectionalLights + &quot;\n&quot;;</span>
<span class="nc" id="L662">				prefix += &quot;#define numPointLights &quot; + config.numPointLights + &quot;\n&quot;;</span>
<span class="nc" id="L663">				prefix += &quot;#define numSpotLights &quot; + config.numSpotLights + &quot;\n&quot;;</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">				if (attributes.has(ColorAttribute.Fog)) {</span>
<span class="nc" id="L665">					prefix += &quot;#define fogFlag\n&quot;;</span>
				}
<span class="nc bnc" id="L667" title="All 2 branches missed.">				if (renderable.environment.shadowMap != null) prefix += &quot;#define shadowMapFlag\n&quot;;</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">				if (attributes.has(CubemapAttribute.EnvironmentMap)) prefix += &quot;#define environmentCubemapFlag\n&quot;;</span>
			}
		}
<span class="nc" id="L671">		final int n = renderable.meshPart.mesh.getVertexAttributes().size();</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">		for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L673">			final VertexAttribute attr = renderable.meshPart.mesh.getVertexAttributes().get(i);</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">			if (attr.usage == Usage.BoneWeight)</span>
<span class="nc" id="L675">				prefix += &quot;#define boneWeight&quot; + attr.unit + &quot;Flag\n&quot;;</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">			else if (attr.usage == Usage.TextureCoordinates) prefix += &quot;#define texCoord&quot; + attr.unit + &quot;Flag\n&quot;;</span>
		}
<span class="nc bnc" id="L678" title="All 2 branches missed.">		if ((attributesMask &amp; BlendingAttribute.Type) == BlendingAttribute.Type)</span>
<span class="nc" id="L679">			prefix += &quot;#define &quot; + BlendingAttribute.Alias + &quot;Flag\n&quot;;</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">		if ((attributesMask &amp; TextureAttribute.Diffuse) == TextureAttribute.Diffuse) {</span>
<span class="nc" id="L681">			prefix += &quot;#define &quot; + TextureAttribute.DiffuseAlias + &quot;Flag\n&quot;;</span>
<span class="nc" id="L682">			prefix += &quot;#define &quot; + TextureAttribute.DiffuseAlias + &quot;Coord texCoord0\n&quot;; // FIXME implement UV mapping</span>
		}
<span class="nc bnc" id="L684" title="All 2 branches missed.">		if ((attributesMask &amp; TextureAttribute.Specular) == TextureAttribute.Specular) {</span>
<span class="nc" id="L685">			prefix += &quot;#define &quot; + TextureAttribute.SpecularAlias + &quot;Flag\n&quot;;</span>
<span class="nc" id="L686">			prefix += &quot;#define &quot; + TextureAttribute.SpecularAlias + &quot;Coord texCoord0\n&quot;; // FIXME implement UV mapping</span>
		}
<span class="nc bnc" id="L688" title="All 2 branches missed.">		if ((attributesMask &amp; TextureAttribute.Normal) == TextureAttribute.Normal) {</span>
<span class="nc" id="L689">			prefix += &quot;#define &quot; + TextureAttribute.NormalAlias + &quot;Flag\n&quot;;</span>
<span class="nc" id="L690">			prefix += &quot;#define &quot; + TextureAttribute.NormalAlias + &quot;Coord texCoord0\n&quot;; // FIXME implement UV mapping</span>
		}
<span class="nc bnc" id="L692" title="All 2 branches missed.">		if ((attributesMask &amp; TextureAttribute.Emissive) == TextureAttribute.Emissive) {</span>
<span class="nc" id="L693">			prefix += &quot;#define &quot; + TextureAttribute.EmissiveAlias + &quot;Flag\n&quot;;</span>
<span class="nc" id="L694">			prefix += &quot;#define &quot; + TextureAttribute.EmissiveAlias + &quot;Coord texCoord0\n&quot;; // FIXME implement UV mapping</span>
		}
<span class="nc bnc" id="L696" title="All 2 branches missed.">		if ((attributesMask &amp; TextureAttribute.Reflection) == TextureAttribute.Reflection) {</span>
<span class="nc" id="L697">			prefix += &quot;#define &quot; + TextureAttribute.ReflectionAlias + &quot;Flag\n&quot;;</span>
<span class="nc" id="L698">			prefix += &quot;#define &quot; + TextureAttribute.ReflectionAlias + &quot;Coord texCoord0\n&quot;; // FIXME implement UV mapping</span>
		}
<span class="nc bnc" id="L700" title="All 2 branches missed.">		if ((attributesMask &amp; TextureAttribute.Ambient) == TextureAttribute.Ambient) {</span>
<span class="nc" id="L701">			prefix += &quot;#define &quot; + TextureAttribute.AmbientAlias + &quot;Flag\n&quot;;</span>
<span class="nc" id="L702">			prefix += &quot;#define &quot; + TextureAttribute.AmbientAlias + &quot;Coord texCoord0\n&quot;; // FIXME implement UV mapping</span>
		}
<span class="nc bnc" id="L704" title="All 2 branches missed.">		if ((attributesMask &amp; ColorAttribute.Diffuse) == ColorAttribute.Diffuse)</span>
<span class="nc" id="L705">			prefix += &quot;#define &quot; + ColorAttribute.DiffuseAlias + &quot;Flag\n&quot;;</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">		if ((attributesMask &amp; ColorAttribute.Specular) == ColorAttribute.Specular)</span>
<span class="nc" id="L707">			prefix += &quot;#define &quot; + ColorAttribute.SpecularAlias + &quot;Flag\n&quot;;</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">		if ((attributesMask &amp; ColorAttribute.Emissive) == ColorAttribute.Emissive)</span>
<span class="nc" id="L709">			prefix += &quot;#define &quot; + ColorAttribute.EmissiveAlias + &quot;Flag\n&quot;;</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">		if ((attributesMask &amp; ColorAttribute.Reflection) == ColorAttribute.Reflection)</span>
<span class="nc" id="L711">			prefix += &quot;#define &quot; + ColorAttribute.ReflectionAlias + &quot;Flag\n&quot;;</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">		if ((attributesMask &amp; FloatAttribute.Shininess) == FloatAttribute.Shininess)</span>
<span class="nc" id="L713">			prefix += &quot;#define &quot; + FloatAttribute.ShininessAlias + &quot;Flag\n&quot;;</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">		if ((attributesMask &amp; FloatAttribute.AlphaTest) == FloatAttribute.AlphaTest)</span>
<span class="nc" id="L715">			prefix += &quot;#define &quot; + FloatAttribute.AlphaTestAlias + &quot;Flag\n&quot;;</span>
<span class="nc bnc" id="L716" title="All 4 branches missed.">		if (renderable.bones != null &amp;&amp; config.numBones &gt; 0) prefix += &quot;#define numBones &quot; + config.numBones + &quot;\n&quot;;</span>
<span class="nc" id="L717">		return prefix;</span>
	}

	@Override
	public boolean canRender (final Renderable renderable) {
<span class="nc" id="L722">		final long renderableMask = combineAttributeMasks(renderable);</span>
<span class="nc bnc" id="L723" title="All 2 branches missed.">		return (attributesMask == (renderableMask | optionalAttributes))</span>
<span class="nc bnc" id="L724" title="All 6 branches missed.">			&amp;&amp; (vertexMask == renderable.meshPart.mesh.getVertexAttributes().getMaskWithSizePacked()) &amp;&amp; (renderable.environment != null) == lighting;</span>
	}

	@Override
	public int compareTo (Shader other) {
<span class="nc bnc" id="L729" title="All 2 branches missed.">		if (other == null) return -1;</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">		if (other == this) return 0;</span>
<span class="nc" id="L731">		return 0; // FIXME compare shaders on their impact on performance</span>
	}

	@Override
	public boolean equals (Object obj) {
<span class="nc bnc" id="L736" title="All 4 branches missed.">		return (obj instanceof DefaultShader) &amp;&amp; equals((DefaultShader) obj);</span>
	}

	public boolean equals (DefaultShader obj) {
<span class="nc bnc" id="L740" title="All 2 branches missed.">		return (obj == this);</span>
	}

<span class="nc" id="L743">	private final Matrix3 normalMatrix = new Matrix3();</span>
	private float time;
	private boolean lightsSet;

	@Override
	public void begin (final Camera camera, final RenderContext context) {
<span class="nc" id="L749">		super.begin(camera, context);</span>

<span class="nc bnc" id="L751" title="All 2 branches missed.">		for (final DirectionalLight dirLight : directionalLights)</span>
<span class="nc" id="L752">			dirLight.set(0, 0, 0, 0, -1, 0);</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">		for (final PointLight pointLight : pointLights)</span>
<span class="nc" id="L754">			pointLight.set(0, 0, 0, 0, 0, 0, 0);</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">		for (final SpotLight spotLight : spotLights)</span>
<span class="nc" id="L756">			spotLight.set(0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 1, 0);</span>
<span class="nc" id="L757">		lightsSet = false;</span>

<span class="nc bnc" id="L759" title="All 2 branches missed.">		if (has(u_time)) set(u_time, time += Gdx.graphics.getDeltaTime());</span>
<span class="nc" id="L760">	}</span>

	@Override
	public void render (Renderable renderable, Attributes combinedAttributes) {
<span class="nc bnc" id="L764" title="All 2 branches missed.">		if (!combinedAttributes.has(BlendingAttribute.Type))</span>
<span class="nc" id="L765">			context.setBlending(false, GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA);</span>
<span class="nc" id="L766">		bindMaterial(combinedAttributes);</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">		if (lighting) bindLights(renderable, combinedAttributes);</span>
<span class="nc" id="L768">		super.render(renderable, combinedAttributes);</span>
<span class="nc" id="L769">	}</span>

	@Override
	public void end () {
<span class="nc" id="L773">		super.end();</span>
<span class="nc" id="L774">	}</span>

	protected void bindMaterial (final Attributes attributes) {
<span class="nc bnc" id="L777" title="All 2 branches missed.">		int cullFace = config.defaultCullFace == -1 ? defaultCullFace : config.defaultCullFace;</span>
<span class="nc bnc" id="L778" title="All 2 branches missed.">		int depthFunc = config.defaultDepthFunc == -1 ? defaultDepthFunc : config.defaultDepthFunc;</span>
<span class="nc" id="L779">		float depthRangeNear = 0f;</span>
<span class="nc" id="L780">		float depthRangeFar = 1f;</span>
<span class="nc" id="L781">		boolean depthMask = true;</span>

<span class="nc bnc" id="L783" title="All 2 branches missed.">		for (final Attribute attr : attributes) {</span>
<span class="nc" id="L784">			final long t = attr.type;</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">			if (BlendingAttribute.is(t)) {</span>
<span class="nc" id="L786">				context.setBlending(true, ((BlendingAttribute)attr).sourceFunction, ((BlendingAttribute)attr).destFunction);</span>
<span class="nc" id="L787">				set(u_opacity, ((BlendingAttribute)attr).opacity);</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">			} else if ((t &amp; IntAttribute.CullFace) == IntAttribute.CullFace)</span>
<span class="nc" id="L789">				cullFace = ((IntAttribute)attr).value;</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">			else if ((t &amp; FloatAttribute.AlphaTest) == FloatAttribute.AlphaTest)</span>
<span class="nc" id="L791">				set(u_alphaTest, ((FloatAttribute)attr).value);</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">			else if ((t &amp; DepthTestAttribute.Type) == DepthTestAttribute.Type) {</span>
<span class="nc" id="L793">				DepthTestAttribute dta = (DepthTestAttribute)attr;</span>
<span class="nc" id="L794">				depthFunc = dta.depthFunc;</span>
<span class="nc" id="L795">				depthRangeNear = dta.depthRangeNear;</span>
<span class="nc" id="L796">				depthRangeFar = dta.depthRangeFar;</span>
<span class="nc" id="L797">				depthMask = dta.depthMask;</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">			} else if (!config.ignoreUnimplemented) throw new GdxRuntimeException(&quot;Unknown material attribute: &quot; + attr.toString());</span>
<span class="nc" id="L799">		}</span>

<span class="nc" id="L801">		context.setCullFace(cullFace);</span>
<span class="nc" id="L802">		context.setDepthTest(depthFunc, depthRangeNear, depthRangeFar);</span>
<span class="nc" id="L803">		context.setDepthMask(depthMask);</span>
<span class="nc" id="L804">	}</span>

<span class="nc" id="L806">	private final Vector3 tmpV1 = new Vector3();</span>

	protected void bindLights (final Renderable renderable, final Attributes attributes) {
<span class="nc" id="L809">		final Environment lights = renderable.environment;</span>
<span class="nc" id="L810">		final DirectionalLightsAttribute dla = attributes.get(DirectionalLightsAttribute.class, DirectionalLightsAttribute.Type);</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">		final Array&lt;DirectionalLight&gt; dirs = dla == null ? null : dla.lights;</span>
<span class="nc" id="L812">		final PointLightsAttribute pla = attributes.get(PointLightsAttribute.class, PointLightsAttribute.Type);</span>
<span class="nc bnc" id="L813" title="All 2 branches missed.">		final Array&lt;PointLight&gt; points = pla == null ? null : pla.lights;</span>
<span class="nc" id="L814">		final SpotLightsAttribute sla = attributes.get(SpotLightsAttribute.class, SpotLightsAttribute.Type);</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">		final Array&lt;SpotLight&gt; spots = sla == null ? null : sla.lights;</span>

<span class="nc bnc" id="L817" title="All 2 branches missed.">		if (dirLightsLoc &gt;= 0) {</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">			for (int i = 0; i &lt; directionalLights.length; i++) {</span>
<span class="nc bnc" id="L819" title="All 4 branches missed.">				if (dirs == null || i &gt;= dirs.size) {</span>
<span class="nc bnc" id="L820" title="All 8 branches missed.">					if (lightsSet &amp;&amp; directionalLights[i].color.r == 0f &amp;&amp; directionalLights[i].color.g == 0f</span>
<span class="nc" id="L821">						&amp;&amp; directionalLights[i].color.b == 0f) continue;</span>
<span class="nc" id="L822">					directionalLights[i].color.set(0, 0, 0, 1);</span>
<span class="nc bnc" id="L823" title="All 4 branches missed.">				} else if (lightsSet &amp;&amp; directionalLights[i].equals(dirs.get(i)))</span>
<span class="nc" id="L824">					continue;</span>
				else
<span class="nc" id="L826">					directionalLights[i].set(dirs.get(i));</span>

<span class="nc" id="L828">				int idx = dirLightsLoc + i * dirLightsSize;</span>
<span class="nc" id="L829">				program.setUniformf(idx + dirLightsColorOffset, directionalLights[i].color.r, directionalLights[i].color.g,</span>
					directionalLights[i].color.b);
<span class="nc" id="L831">				program.setUniformf(idx + dirLightsDirectionOffset, directionalLights[i].direction.x,</span>
					directionalLights[i].direction.y, directionalLights[i].direction.z);
<span class="nc bnc" id="L833" title="All 2 branches missed.">				if (dirLightsSize &lt;= 0) break;</span>
			}
		}

<span class="nc bnc" id="L837" title="All 2 branches missed.">		if (pointLightsLoc &gt;= 0) {</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">			for (int i = 0; i &lt; pointLights.length; i++) {</span>
<span class="nc bnc" id="L839" title="All 4 branches missed.">				if (points == null || i &gt;= points.size) {</span>
<span class="nc bnc" id="L840" title="All 4 branches missed.">					if (lightsSet &amp;&amp; pointLights[i].intensity == 0f) continue;</span>
<span class="nc" id="L841">					pointLights[i].intensity = 0f;</span>
<span class="nc bnc" id="L842" title="All 4 branches missed.">				} else if (lightsSet &amp;&amp; pointLights[i].equals(points.get(i)))</span>
<span class="nc" id="L843">					continue;</span>
				else
<span class="nc" id="L845">					pointLights[i].set(points.get(i));</span>

<span class="nc" id="L847">				int idx = pointLightsLoc + i * pointLightsSize;</span>
<span class="nc" id="L848">				program.setUniformf(idx + pointLightsColorOffset, pointLights[i].color.r * pointLights[i].intensity,</span>
					pointLights[i].color.g * pointLights[i].intensity, pointLights[i].color.b * pointLights[i].intensity);
<span class="nc" id="L850">				program.setUniformf(idx + pointLightsPositionOffset, pointLights[i].position.x, pointLights[i].position.y,</span>
					pointLights[i].position.z);
<span class="nc bnc" id="L852" title="All 2 branches missed.">				if (pointLightsIntensityOffset &gt;= 0) program.setUniformf(idx + pointLightsIntensityOffset, pointLights[i].intensity);</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">				if (pointLightsSize &lt;= 0) break;</span>
			}
		}

<span class="nc bnc" id="L857" title="All 2 branches missed.">		if (spotLightsLoc &gt;= 0) {</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">			for (int i = 0; i &lt; spotLights.length; i++) {</span>
<span class="nc bnc" id="L859" title="All 4 branches missed.">				if (spots == null || i &gt;= spots.size) {</span>
<span class="nc bnc" id="L860" title="All 4 branches missed.">					if (lightsSet &amp;&amp; spotLights[i].intensity == 0f) continue;</span>
<span class="nc" id="L861">					spotLights[i].intensity = 0f;</span>
<span class="nc bnc" id="L862" title="All 4 branches missed.">				} else if (lightsSet &amp;&amp; spotLights[i].equals(spots.get(i)))</span>
<span class="nc" id="L863">					continue;</span>
				else
<span class="nc" id="L865">					spotLights[i].set(spots.get(i));</span>

<span class="nc" id="L867">				int idx = spotLightsLoc + i * spotLightsSize;</span>
<span class="nc" id="L868">				program.setUniformf(idx + spotLightsColorOffset, spotLights[i].color.r * spotLights[i].intensity,</span>
					spotLights[i].color.g * spotLights[i].intensity, spotLights[i].color.b * spotLights[i].intensity);
<span class="nc" id="L870">				program.setUniformf(idx + spotLightsPositionOffset, spotLights[i].position);</span>
<span class="nc" id="L871">				program.setUniformf(idx + spotLightsDirectionOffset, spotLights[i].direction);</span>
<span class="nc" id="L872">				program.setUniformf(idx + spotLightsCutoffAngleOffset, spotLights[i].cutoffAngle);</span>
<span class="nc" id="L873">				program.setUniformf(idx + spotLightsExponentOffset, spotLights[i].exponent);</span>
<span class="nc bnc" id="L874" title="All 2 branches missed.">				if (spotLightsIntensityOffset &gt;= 0)</span>
<span class="nc" id="L875">					program.setUniformf(idx + spotLightsIntensityOffset, spotLights[i].intensity);</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">				if (spotLightsSize &lt;= 0) break;</span>
			}
		}

<span class="nc bnc" id="L880" title="All 2 branches missed.">		if (attributes.has(ColorAttribute.Fog)) {</span>
<span class="nc" id="L881">			set(u_fogColor, ((ColorAttribute)attributes.get(ColorAttribute.Fog)).color);</span>
		}

<span class="nc bnc" id="L884" title="All 4 branches missed.">		if (lights != null &amp;&amp; lights.shadowMap != null) {</span>
<span class="nc" id="L885">			set(u_shadowMapProjViewTrans, lights.shadowMap.getProjViewTrans());</span>
<span class="nc" id="L886">			set(u_shadowTexture, lights.shadowMap.getDepthMap());</span>
<span class="nc" id="L887">			set(u_shadowPCFOffset, 1.f / (2f * lights.shadowMap.getDepthMap().texture.getWidth()));</span>
		}

<span class="nc" id="L890">		lightsSet = true;</span>
<span class="nc" id="L891">	}</span>

	@Override
	public void dispose () {
<span class="nc" id="L895">		program.dispose();</span>
<span class="nc" id="L896">		super.dispose();</span>
<span class="nc" id="L897">	}</span>

	public int getDefaultCullFace () {
<span class="nc bnc" id="L900" title="All 2 branches missed.">		return config.defaultCullFace == -1 ? defaultCullFace : config.defaultCullFace;</span>
	}

	public void setDefaultCullFace (int cullFace) {
<span class="nc" id="L904">		config.defaultCullFace = cullFace;</span>
<span class="nc" id="L905">	}</span>

	public int getDefaultDepthFunc () {
<span class="nc bnc" id="L908" title="All 2 branches missed.">		return config.defaultDepthFunc == -1 ? defaultDepthFunc : config.defaultDepthFunc;</span>
	}

	public void setDefaultDepthFunc (int depthFunc) {
<span class="nc" id="L912">		config.defaultDepthFunc = depthFunc;</span>
<span class="nc" id="L913">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>