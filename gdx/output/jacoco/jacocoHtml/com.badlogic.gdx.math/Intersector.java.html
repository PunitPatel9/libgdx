<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Intersector.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">gdx</a> &gt; <a href="index.source.html" class="el_package">com.badlogic.gdx.math</a> &gt; <span class="el_source">Intersector.java</span></div><h1>Intersector.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2011 See AUTHORS file.
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

package com.badlogic.gdx.math;

import java.util.Arrays;
import java.util.List;

import com.badlogic.gdx.math.Plane.PlaneSide;
import com.badlogic.gdx.math.collision.BoundingBox;
import com.badlogic.gdx.math.collision.Ray;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.FloatArray;

/** Class offering various static methods for intersection testing between different geometric objects.
 * 
 * @author badlogicgames@gmail.com
 * @author jan.stria
 * @author Nathan Sweet */
<span class="nc" id="L33">public final class Intersector {</span>
<span class="fc" id="L34">	private final static Vector3 v0 = new Vector3();</span>
<span class="fc" id="L35">	private final static Vector3 v1 = new Vector3();</span>
<span class="fc" id="L36">	private final static Vector3 v2 = new Vector3();</span>
<span class="fc" id="L37">	private final static FloatArray floatArray = new FloatArray();</span>
<span class="fc" id="L38">	private final static FloatArray floatArray2 = new FloatArray();</span>

	/** Returns whether the given point is inside the triangle. This assumes that the point is on the plane of the triangle. No
	 * check is performed that this is the case.
	 * 
	 * @param point the point
	 * @param t1 the first vertex of the triangle
	 * @param t2 the second vertex of the triangle
	 * @param t3 the third vertex of the triangle
	 * @return whether the point is in the triangle */
	public static boolean isPointInTriangle (Vector3 point, Vector3 t1, Vector3 t2, Vector3 t3) {
<span class="nc" id="L49">		v0.set(t1).sub(point);</span>
<span class="nc" id="L50">		v1.set(t2).sub(point);</span>
<span class="nc" id="L51">		v2.set(t3).sub(point);</span>

<span class="nc" id="L53">		float ab = v0.dot(v1);</span>
<span class="nc" id="L54">		float ac = v0.dot(v2);</span>
<span class="nc" id="L55">		float bc = v1.dot(v2);</span>
<span class="nc" id="L56">		float cc = v2.dot(v2);</span>

<span class="nc bnc" id="L58" title="All 2 branches missed.">		if (bc * ac - cc * ab &lt; 0) return false;</span>
<span class="nc" id="L59">		float bb = v1.dot(v1);</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">		if (ab * bc - ac * bb &lt; 0) return false;</span>
<span class="nc" id="L61">		return true;</span>
	}

	/** Returns true if the given point is inside the triangle. */
	public static boolean isPointInTriangle (Vector2 p, Vector2 a, Vector2 b, Vector2 c) {
<span class="nc" id="L66">		float px1 = p.x - a.x;</span>
<span class="nc" id="L67">		float py1 = p.y - a.y;</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">		boolean side12 = (b.x - a.x) * py1 - (b.y - a.y) * px1 &gt; 0;</span>
<span class="nc bnc" id="L69" title="All 4 branches missed.">		if ((c.x - a.x) * py1 - (c.y - a.y) * px1 &gt; 0 == side12) return false;</span>
<span class="nc bnc" id="L70" title="All 4 branches missed.">		if ((c.x - b.x) * (p.y - b.y) - (c.y - b.y) * (p.x - b.x) &gt; 0 != side12) return false;</span>
<span class="nc" id="L71">		return true;</span>
	}

	/** Returns true if the given point is inside the triangle. */
	public static boolean isPointInTriangle (float px, float py, float ax, float ay, float bx, float by, float cx, float cy) {
<span class="nc" id="L76">		float px1 = px - ax;</span>
<span class="nc" id="L77">		float py1 = py - ay;</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">		boolean side12 = (bx - ax) * py1 - (by - ay) * px1 &gt; 0;</span>
<span class="nc bnc" id="L79" title="All 4 branches missed.">		if ((cx - ax) * py1 - (cy - ay) * px1 &gt; 0 == side12) return false;</span>
<span class="nc bnc" id="L80" title="All 4 branches missed.">		if ((cx - bx) * (py - by) - (cy - by) * (px - bx) &gt; 0 != side12) return false;</span>
<span class="nc" id="L81">		return true;</span>
	}

	public static boolean intersectSegmentPlane (Vector3 start, Vector3 end, Plane plane, Vector3 intersection) {
<span class="nc" id="L85">		Vector3 dir = v0.set(end).sub(start);</span>
<span class="nc" id="L86">		float denom = dir.dot(plane.getNormal());</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">		if (denom == 0f) return false;</span>
<span class="nc" id="L88">		float t = -(start.dot(plane.getNormal()) + plane.getD()) / denom;</span>
<span class="nc bnc" id="L89" title="All 4 branches missed.">		if (t &lt; 0 || t &gt; 1) return false;</span>

<span class="nc" id="L91">		intersection.set(start).add(dir.scl(t));</span>
<span class="nc" id="L92">		return true;</span>
	}

	/** Determines on which side of the given line the point is. Returns -1 if the point is on the left side of the line, 0 if the
	 * point is on the line and 1 if the point is on the right side of the line. Left and right are relative to the lines direction
	 * which is linePoint1 to linePoint2. */
	public static int pointLineSide (Vector2 linePoint1, Vector2 linePoint2, Vector2 point) {
<span class="nc" id="L99">		return (int)Math.signum(</span>
			(linePoint2.x - linePoint1.x) * (point.y - linePoint1.y) - (linePoint2.y - linePoint1.y) * (point.x - linePoint1.x));
	}

	public static int pointLineSide (float linePoint1X, float linePoint1Y, float linePoint2X, float linePoint2Y, float pointX,
		float pointY) {
<span class="nc" id="L105">		return (int)Math</span>
<span class="nc" id="L106">			.signum((linePoint2X - linePoint1X) * (pointY - linePoint1Y) - (linePoint2Y - linePoint1Y) * (pointX - linePoint1X));</span>
	}

	/** Checks whether the given point is in the polygon.
	 * @param polygon The polygon vertices passed as an array
	 * @param point The point
	 * @return true if the point is in the polygon */
	public static boolean isPointInPolygon (Array&lt;Vector2&gt; polygon, Vector2 point) {
<span class="nc" id="L114">		Vector2 last = polygon.peek();</span>
<span class="nc" id="L115">		float x = point.x, y = point.y;</span>
<span class="nc" id="L116">		boolean oddNodes = false;</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">		for (int i = 0; i &lt; polygon.size; i++) {</span>
<span class="nc" id="L118">			Vector2 vertex = polygon.get(i);</span>
<span class="nc bnc" id="L119" title="All 8 branches missed.">			if ((vertex.y &lt; y &amp;&amp; last.y &gt;= y) || (last.y &lt; y &amp;&amp; vertex.y &gt;= y)) {</span>
<span class="nc bnc" id="L120" title="All 4 branches missed.">				if (vertex.x + (y - vertex.y) / (last.y - vertex.y) * (last.x - vertex.x) &lt; x) oddNodes = !oddNodes;</span>
			}
<span class="nc" id="L122">			last = vertex;</span>
		}
<span class="nc" id="L124">		return oddNodes;</span>
	}

	/** Returns true if the specified point is in the polygon.
	 * @param offset Starting polygon index.
	 * @param count Number of array indices to use after offset. */
	public static boolean isPointInPolygon (float[] polygon, int offset, int count, float x, float y) {
<span class="nc" id="L131">		boolean oddNodes = false;</span>
<span class="nc" id="L132">		float sx = polygon[offset], sy = polygon[offset + 1], y1 = sy;</span>
<span class="nc" id="L133">		int yi = offset + 3;</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">		for (int n = offset + count; yi &lt; n; yi += 2) {</span>
<span class="nc" id="L135">			float y2 = polygon[yi];</span>
<span class="nc bnc" id="L136" title="All 8 branches missed.">			if ((y2 &lt; y &amp;&amp; y1 &gt;= y) || (y1 &lt; y &amp;&amp; y2 &gt;= y)) {</span>
<span class="nc" id="L137">				float x2 = polygon[yi - 1];</span>
<span class="nc bnc" id="L138" title="All 4 branches missed.">				if (x2 + (y - y2) / (y1 - y2) * (polygon[yi - 3] - x2) &lt; x) oddNodes = !oddNodes;</span>
			}
<span class="nc" id="L140">			y1 = y2;</span>
		}
<span class="nc bnc" id="L142" title="All 8 branches missed.">		if ((sy &lt; y &amp;&amp; y1 &gt;= y) || (y1 &lt; y &amp;&amp; sy &gt;= y)) {</span>
<span class="nc bnc" id="L143" title="All 4 branches missed.">			if (sx + (y - sy) / (y1 - sy) * (polygon[yi - 3] - sx) &lt; x) oddNodes = !oddNodes;</span>
		}
<span class="nc" id="L145">		return oddNodes;</span>
	}

<span class="fc" id="L148">	private final static Vector2 ip = new Vector2();</span>
<span class="fc" id="L149">	private final static Vector2 ep1 = new Vector2();</span>
<span class="fc" id="L150">	private final static Vector2 ep2 = new Vector2();</span>
<span class="fc" id="L151">	private final static Vector2 s = new Vector2();</span>
<span class="fc" id="L152">	private final static Vector2 e = new Vector2();</span>

	/** Intersects two convex polygons with clockwise vertices and sets the overlap polygon resulting from the intersection.
	 * Follows the Sutherland-Hodgman algorithm.
	 * @param p1 The polygon that is being clipped
	 * @param p2 The clip polygon
	 * @param overlap The intersection of the two polygons (can be null, if an intersection polygon is not needed)
	 * @return Whether the two polygons intersect. */
	public static boolean intersectPolygons (Polygon p1, Polygon p2, Polygon overlap) {
<span class="nc bnc" id="L161" title="All 4 branches missed.">		if (p1.getVertices().length == 0 || p2.getVertices().length == 0) {</span>
<span class="nc" id="L162">			return false;</span>
		}
<span class="nc" id="L164">		Vector2 ip = Intersector.ip, ep1 = Intersector.ep1, ep2 = Intersector.ep2, s = Intersector.s, e = Intersector.e;</span>
<span class="nc" id="L165">		FloatArray floatArray = Intersector.floatArray, floatArray2 = Intersector.floatArray2;</span>
<span class="nc" id="L166">		floatArray.clear();</span>
<span class="nc" id="L167">		floatArray2.clear();</span>
<span class="nc" id="L168">		floatArray2.addAll(p1.getTransformedVertices());</span>
<span class="nc" id="L169">		float[] vertices2 = p2.getTransformedVertices();</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">		for (int i = 0, last = vertices2.length - 2; i &lt;= last; i += 2) {</span>
<span class="nc" id="L171">			ep1.set(vertices2[i], vertices2[i + 1]);</span>
			// wrap around to beginning of array if index points to end;
<span class="nc bnc" id="L173" title="All 2 branches missed.">			if (i &lt; last)</span>
<span class="nc" id="L174">				ep2.set(vertices2[i + 2], vertices2[i + 3]);</span>
			else
<span class="nc" id="L176">				ep2.set(vertices2[0], vertices2[1]);</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">			if (floatArray2.size == 0) return false;</span>
<span class="nc" id="L178">			s.set(floatArray2.get(floatArray2.size - 2), floatArray2.get(floatArray2.size - 1));</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">			for (int j = 0; j &lt; floatArray2.size; j += 2) {</span>
<span class="nc" id="L180">				e.set(floatArray2.get(j), floatArray2.get(j + 1));</span>
				// determine if point is inside clip edge
<span class="nc bnc" id="L182" title="All 2 branches missed.">				boolean side = Intersector.pointLineSide(ep2, ep1, s) &gt; 0;</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">				if (Intersector.pointLineSide(ep2, ep1, e) &gt; 0) {</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">					if (!side) {</span>
<span class="nc" id="L185">						Intersector.intersectLines(s, e, ep1, ep2, ip);</span>
<span class="nc bnc" id="L186" title="All 4 branches missed.">						if (floatArray.size &lt; 2 || floatArray.get(floatArray.size - 2) != ip.x</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">							|| floatArray.get(floatArray.size - 1) != ip.y) {</span>
<span class="nc" id="L188">							floatArray.add(ip.x);</span>
<span class="nc" id="L189">							floatArray.add(ip.y);</span>
						}
					}
<span class="nc" id="L192">					floatArray.add(e.x);</span>
<span class="nc" id="L193">					floatArray.add(e.y);</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">				} else if (side) {</span>
<span class="nc" id="L195">					Intersector.intersectLines(s, e, ep1, ep2, ip);</span>
<span class="nc" id="L196">					floatArray.add(ip.x);</span>
<span class="nc" id="L197">					floatArray.add(ip.y);</span>
				}
<span class="nc" id="L199">				s.set(e.x, e.y);</span>
			}
<span class="nc" id="L201">			floatArray2.clear();</span>
<span class="nc" id="L202">			floatArray2.addAll(floatArray);</span>
<span class="nc" id="L203">			floatArray.clear();</span>
		}
<span class="nc bnc" id="L205" title="All 2 branches missed.">		if (floatArray2.size != 0) {</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">			if (overlap != null) {</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">				if (overlap.getVertices().length == floatArray2.size)</span>
<span class="nc" id="L208">					System.arraycopy(floatArray2.items, 0, overlap.getVertices(), 0, floatArray2.size);</span>
				else
<span class="nc" id="L210">					overlap.setVertices(floatArray2.toArray());</span>
			}
<span class="nc" id="L212">			return true;</span>
		}
<span class="nc" id="L214">		return false;</span>
	}

	/** Returns true if the specified poygons intersect. */
	static public boolean intersectPolygons (FloatArray polygon1, FloatArray polygon2) {
<span class="nc bnc" id="L219" title="All 2 branches missed.">		if (Intersector.isPointInPolygon(polygon1.items, 0, polygon1.size, polygon2.items[0], polygon2.items[1])) return true;</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">		if (Intersector.isPointInPolygon(polygon2.items, 0, polygon2.size, polygon1.items[0], polygon1.items[1])) return true;</span>
<span class="nc" id="L221">		return intersectPolygonEdges(polygon1, polygon2);</span>
	}

	/** Returns true if the lines of the specified poygons intersect. */
	static public boolean intersectPolygonEdges (FloatArray polygon1, FloatArray polygon2) {
<span class="nc" id="L226">		int last1 = polygon1.size - 2, last2 = polygon2.size - 2;</span>
<span class="nc" id="L227">		float[] p1 = polygon1.items, p2 = polygon2.items;</span>
<span class="nc" id="L228">		float x1 = p1[last1], y1 = p1[last1 + 1];</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">		for (int i = 0; i &lt;= last1; i += 2) {</span>
<span class="nc" id="L230">			float x2 = p1[i], y2 = p1[i + 1];</span>
<span class="nc" id="L231">			float x3 = p2[last2], y3 = p2[last2 + 1];</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">			for (int j = 0; j &lt;= last2; j += 2) {</span>
<span class="nc" id="L233">				float x4 = p2[j], y4 = p2[j + 1];</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">				if (intersectSegments(x1, y1, x2, y2, x3, y3, x4, y4, null)) return true;</span>
<span class="nc" id="L235">				x3 = x4;</span>
<span class="nc" id="L236">				y3 = y4;</span>
			}
<span class="nc" id="L238">			x1 = x2;</span>
<span class="nc" id="L239">			y1 = y2;</span>
		}
<span class="nc" id="L241">		return false;</span>
	}

	/** Returns the distance between the given line and point. Note the specified line is not a line segment. */
	public static float distanceLinePoint (float startX, float startY, float endX, float endY, float pointX, float pointY) {
<span class="nc" id="L246">		float normalLength = (float)Math.sqrt((endX - startX) * (endX - startX) + (endY - startY) * (endY - startY));</span>
<span class="nc" id="L247">		return Math.abs((pointX - startX) * (endY - startY) - (pointY - startY) * (endX - startX)) / normalLength;</span>
	}

	/** Returns the distance between the given segment and point. */
	public static float distanceSegmentPoint (float startX, float startY, float endX, float endY, float pointX, float pointY) {
<span class="nc" id="L252">		return nearestSegmentPoint(startX, startY, endX, endY, pointX, pointY, v2tmp).dst(pointX, pointY);</span>
	}

	/** Returns the distance between the given segment and point. */
	public static float distanceSegmentPoint (Vector2 start, Vector2 end, Vector2 point) {
<span class="nc" id="L257">		return nearestSegmentPoint(start, end, point, v2tmp).dst(point);</span>
	}

	/** Returns a point on the segment nearest to the specified point. */
	public static Vector2 nearestSegmentPoint (Vector2 start, Vector2 end, Vector2 point, Vector2 nearest) {
<span class="nc" id="L262">		float length2 = start.dst2(end);</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">		if (length2 == 0) return nearest.set(start);</span>
<span class="nc" id="L264">		float t = ((point.x - start.x) * (end.x - start.x) + (point.y - start.y) * (end.y - start.y)) / length2;</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">		if (t &lt; 0) return nearest.set(start);</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">		if (t &gt; 1) return nearest.set(end);</span>
<span class="nc" id="L267">		return nearest.set(start.x + t * (end.x - start.x), start.y + t * (end.y - start.y));</span>
	}

	/** Returns a point on the segment nearest to the specified point. */
	public static Vector2 nearestSegmentPoint (float startX, float startY, float endX, float endY, float pointX, float pointY,
		Vector2 nearest) {
<span class="nc" id="L273">		final float xDiff = endX - startX;</span>
<span class="nc" id="L274">		final float yDiff = endY - startY;</span>
<span class="nc" id="L275">		float length2 = xDiff * xDiff + yDiff * yDiff;</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">		if (length2 == 0) return nearest.set(startX, startY);</span>
<span class="nc" id="L277">		float t = ((pointX - startX) * (endX - startX) + (pointY - startY) * (endY - startY)) / length2;</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">		if (t &lt; 0) return nearest.set(startX, startY);</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">		if (t &gt; 1) return nearest.set(endX, endY);</span>
<span class="nc" id="L280">		return nearest.set(startX + t * (endX - startX), startY + t * (endY - startY));</span>
	}

	/** Returns whether the given line segment intersects the given circle.
	 * @param start The start point of the line segment
	 * @param end The end point of the line segment
	 * @param center The center of the circle
	 * @param squareRadius The squared radius of the circle
	 * @return Whether the line segment and the circle intersect */
	public static boolean intersectSegmentCircle (Vector2 start, Vector2 end, Vector2 center, float squareRadius) {
<span class="nc" id="L290">		tmp.set(end.x - start.x, end.y - start.y, 0);</span>
<span class="nc" id="L291">		tmp1.set(center.x - start.x, center.y - start.y, 0);</span>
<span class="nc" id="L292">		float l = tmp.len();</span>
<span class="nc" id="L293">		float u = tmp1.dot(tmp.nor());</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">		if (u &lt;= 0) {</span>
<span class="nc" id="L295">			tmp2.set(start.x, start.y, 0);</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">		} else if (u &gt;= l) {</span>
<span class="nc" id="L297">			tmp2.set(end.x, end.y, 0);</span>
		} else {
<span class="nc" id="L299">			tmp3.set(tmp.scl(u)); // remember tmp is already normalized</span>
<span class="nc" id="L300">			tmp2.set(tmp3.x + start.x, tmp3.y + start.y, 0);</span>
		}

<span class="nc" id="L303">		float x = center.x - tmp2.x;</span>
<span class="nc" id="L304">		float y = center.y - tmp2.y;</span>

<span class="nc bnc" id="L306" title="All 2 branches missed.">		return x * x + y * y &lt;= squareRadius;</span>
	}

	/** Checks whether the line segment and the circle intersect and returns by how much and in what direction the line has to move
	 * away from the circle to not intersect.
	 * 
	 * @param start The line segment starting point
	 * @param end The line segment end point
	 * @param point The center of the circle
	 * @param radius The radius of the circle
	 * @param displacement The displacement vector set by the method having unit length
	 * @return The displacement or Float.POSITIVE_INFINITY if no intersection is present */
	public static float intersectSegmentCircleDisplace (Vector2 start, Vector2 end, Vector2 point, float radius,
		Vector2 displacement) {
<span class="nc" id="L320">		float u = (point.x - start.x) * (end.x - start.x) + (point.y - start.y) * (end.y - start.y);</span>
<span class="nc" id="L321">		float d = start.dst(end);</span>
<span class="nc" id="L322">		u /= d * d;</span>
<span class="nc bnc" id="L323" title="All 4 branches missed.">		if (u &lt; 0 || u &gt; 1) return Float.POSITIVE_INFINITY;</span>
<span class="nc" id="L324">		tmp.set(end.x, end.y, 0).sub(start.x, start.y, 0);</span>
<span class="nc" id="L325">		tmp2.set(start.x, start.y, 0).add(tmp.scl(u));</span>
<span class="nc" id="L326">		d = tmp2.dst(point.x, point.y, 0);</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">		if (d &lt; radius) {</span>
<span class="nc" id="L328">			displacement.set(point).sub(tmp2.x, tmp2.y).nor();</span>
<span class="nc" id="L329">			return d;</span>
		} else
<span class="nc" id="L331">			return Float.POSITIVE_INFINITY;</span>
	}

	/** Intersect two 2D Rays and return the scalar parameter of the first ray at the intersection point. You can get the
	 * intersection point by: Vector2 point(direction1).scl(scalar).add(start1); For more information, check:
	 * http://stackoverflow.com/a/565282/1091440
	 * @param start1 Where the first ray start
	 * @param direction1 The direction the first ray is pointing
	 * @param start2 Where the second ray start
	 * @param direction2 The direction the second ray is pointing
	 * @return scalar parameter on the first ray describing the point where the intersection happens. May be negative. In case the
	 *         rays are collinear, Float.POSITIVE_INFINITY will be returned. */
	public static float intersectRayRay (Vector2 start1, Vector2 direction1, Vector2 start2, Vector2 direction2) {
<span class="nc" id="L344">		float difx = start2.x - start1.x;</span>
<span class="nc" id="L345">		float dify = start2.y - start1.y;</span>
<span class="nc" id="L346">		float d1xd2 = direction1.x * direction2.y - direction1.y * direction2.x;</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">		if (d1xd2 == 0.0f) {</span>
<span class="nc" id="L348">			return Float.POSITIVE_INFINITY; // collinear</span>
		}
<span class="nc" id="L350">		float d2sx = direction2.x / d1xd2;</span>
<span class="nc" id="L351">		float d2sy = direction2.y / d1xd2;</span>
<span class="nc" id="L352">		return difx * d2sy - dify * d2sx;</span>
	}

	/** Intersects a {@link Ray} and a {@link Plane}. The intersection point is stored in intersection in case an intersection is
	 * present.
	 * 
	 * @param ray The ray
	 * @param plane The plane
	 * @param intersection The vector the intersection point is written to (optional)
	 * @return Whether an intersection is present. */
	public static boolean intersectRayPlane (Ray ray, Plane plane, Vector3 intersection) {
<span class="nc" id="L363">		float denom = ray.direction.dot(plane.getNormal());</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">		if (denom != 0) {</span>
<span class="nc" id="L365">			float t = -(ray.origin.dot(plane.getNormal()) + plane.getD()) / denom;</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">			if (t &lt; 0) return false;</span>

<span class="nc bnc" id="L368" title="All 2 branches missed.">			if (intersection != null) intersection.set(ray.origin).add(v0.set(ray.direction).scl(t));</span>
<span class="nc" id="L369">			return true;</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">		} else if (plane.testPoint(ray.origin) == Plane.PlaneSide.OnPlane) {</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">			if (intersection != null) intersection.set(ray.origin);</span>
<span class="nc" id="L372">			return true;</span>
		} else
<span class="nc" id="L374">			return false;</span>
	}

	/** Intersects a line and a plane. The intersection is returned as the distance from the first point to the plane. In case an
	 * intersection happened, the return value is in the range [0,1]. The intersection point can be recovered by point1 + t *
	 * (point2 - point1) where t is the return value of this method.
	 * @param x
	 * @param y
	 * @param z
	 * @param x2
	 * @param y2
	 * @param z2
	 * @param plane */
	public static float intersectLinePlane (float x, float y, float z, float x2, float y2, float z2, Plane plane,
		Vector3 intersection) {
<span class="fc" id="L389">		Vector3 direction = tmp.set(x2, y2, z2).sub(x, y, z);</span>
<span class="fc" id="L390">		Vector3 origin = tmp2.set(x, y, z);</span>
<span class="fc" id="L391">		float denom = direction.dot(plane.getNormal());</span>
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">		if (denom != 0) {</span>
<span class="fc" id="L393">			float t = -(origin.dot(plane.getNormal()) + plane.getD()) / denom;</span>
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">			if (intersection != null) intersection.set(origin).add(direction.scl(t));</span>
<span class="fc" id="L395">			return t;</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">		} else if (plane.testPoint(origin) == Plane.PlaneSide.OnPlane) {</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">			if (intersection != null) intersection.set(origin);</span>
<span class="nc" id="L398">			return 0;</span>
		}

<span class="nc" id="L401">		return -1;</span>
	}

<span class="fc" id="L404">	private static final Plane p = new Plane(new Vector3(), 0);</span>
<span class="fc" id="L405">	private static final Vector3 i = new Vector3();</span>

	/** Intersect a {@link Ray} and a triangle, returning the intersection point in intersection.
	 * 
	 * @param ray The ray
	 * @param t1 The first vertex of the triangle
	 * @param t2 The second vertex of the triangle
	 * @param t3 The third vertex of the triangle
	 * @param intersection The intersection point (optional)
	 * @return True in case an intersection is present. */
	public static boolean intersectRayTriangle (Ray ray, Vector3 t1, Vector3 t2, Vector3 t3, Vector3 intersection) {
<span class="nc" id="L416">		Vector3 edge1 = v0.set(t2).sub(t1);</span>
<span class="nc" id="L417">		Vector3 edge2 = v1.set(t3).sub(t1);</span>

<span class="nc" id="L419">		Vector3 pvec = v2.set(ray.direction).crs(edge2);</span>
<span class="nc" id="L420">		float det = edge1.dot(pvec);</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">		if (MathUtils.isZero(det)) {</span>
<span class="nc" id="L422">			p.set(t1, t2, t3);</span>
<span class="nc bnc" id="L423" title="All 4 branches missed.">			if (p.testPoint(ray.origin) == PlaneSide.OnPlane &amp;&amp; Intersector.isPointInTriangle(ray.origin, t1, t2, t3)) {</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">				if (intersection != null) intersection.set(ray.origin);</span>
<span class="nc" id="L425">				return true;</span>
			}
<span class="nc" id="L427">			return false;</span>
		}

<span class="nc" id="L430">		det = 1.0f / det;</span>

<span class="nc" id="L432">		Vector3 tvec = i.set(ray.origin).sub(t1);</span>
<span class="nc" id="L433">		float u = tvec.dot(pvec) * det;</span>
<span class="nc bnc" id="L434" title="All 4 branches missed.">		if (u &lt; 0.0f || u &gt; 1.0f) return false;</span>

<span class="nc" id="L436">		Vector3 qvec = tvec.crs(edge1);</span>
<span class="nc" id="L437">		float v = ray.direction.dot(qvec) * det;</span>
<span class="nc bnc" id="L438" title="All 4 branches missed.">		if (v &lt; 0.0f || u + v &gt; 1.0f) return false;</span>

<span class="nc" id="L440">		float t = edge2.dot(qvec) * det;</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">		if (t &lt; 0) return false;</span>

<span class="nc bnc" id="L443" title="All 2 branches missed.">		if (intersection != null) {</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">			if (t &lt;= MathUtils.FLOAT_ROUNDING_ERROR) {</span>
<span class="nc" id="L445">				intersection.set(ray.origin);</span>
			} else {
<span class="nc" id="L447">				ray.getEndPoint(intersection, t);</span>
			}
		}

<span class="nc" id="L451">		return true;</span>
	}

<span class="fc" id="L454">	private static final Vector3 dir = new Vector3();</span>
<span class="fc" id="L455">	private static final Vector3 start = new Vector3();</span>

	/** Intersects a {@link Ray} and a sphere, returning the intersection point in intersection.
	 * 
	 * @param ray The ray, the direction component must be normalized before calling this method
	 * @param center The center of the sphere
	 * @param radius The radius of the sphere
	 * @param intersection The intersection point (optional, can be null)
	 * @return Whether an intersection is present. */
	public static boolean intersectRaySphere (Ray ray, Vector3 center, float radius, Vector3 intersection) {
<span class="nc" id="L465">		final float len = ray.direction.dot(center.x - ray.origin.x, center.y - ray.origin.y, center.z - ray.origin.z);</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">		if (len &lt; 0.f) // behind the ray</span>
<span class="nc" id="L467">			return false;</span>
<span class="nc" id="L468">		final float dst2 = center.dst2(ray.origin.x + ray.direction.x * len, ray.origin.y + ray.direction.y * len,</span>
			ray.origin.z + ray.direction.z * len);
<span class="nc" id="L470">		final float r2 = radius * radius;</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">		if (dst2 &gt; r2) return false;</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">		if (intersection != null) intersection.set(ray.direction).scl(len - (float)Math.sqrt(r2 - dst2)).add(ray.origin);</span>
<span class="nc" id="L473">		return true;</span>
	}

	/** Intersects a {@link Ray} and a {@link BoundingBox}, returning the intersection point in intersection. This intersection is
	 * defined as the point on the ray closest to the origin which is within the specified bounds.
	 * 
	 * &lt;p&gt;
	 * The returned intersection (if any) is guaranteed to be within the bounds of the bounding box, but it can occasionally
	 * diverge slightly from ray, due to small floating-point errors.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;
	 * If the origin of the ray is inside the box, this method returns true and the intersection point is set to the origin of the
	 * ray, accordingly to the definition above.
	 * &lt;/p&gt;
	 * 
	 * @param ray The ray
	 * @param box The box
	 * @param intersection The intersection point (optional)
	 * @return Whether an intersection is present. */
	public static boolean intersectRayBounds (Ray ray, BoundingBox box, Vector3 intersection) {
<span class="nc bnc" id="L494" title="All 2 branches missed.">		if (box.contains(ray.origin)) {</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">			if (intersection != null) intersection.set(ray.origin);</span>
<span class="nc" id="L496">			return true;</span>
		}
<span class="nc" id="L498">		float lowest = 0, t;</span>
<span class="nc" id="L499">		boolean hit = false;</span>

		// min x
<span class="nc bnc" id="L502" title="All 4 branches missed.">		if (ray.origin.x &lt;= box.min.x &amp;&amp; ray.direction.x &gt; 0) {</span>
<span class="nc" id="L503">			t = (box.min.x - ray.origin.x) / ray.direction.x;</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">			if (t &gt;= 0) {</span>
<span class="nc" id="L505">				v2.set(ray.direction).scl(t).add(ray.origin);</span>
<span class="nc bnc" id="L506" title="All 12 branches missed.">				if (v2.y &gt;= box.min.y &amp;&amp; v2.y &lt;= box.max.y &amp;&amp; v2.z &gt;= box.min.z &amp;&amp; v2.z &lt;= box.max.z &amp;&amp; (!hit || t &lt; lowest)) {</span>
<span class="nc" id="L507">					hit = true;</span>
<span class="nc" id="L508">					lowest = t;</span>
				}
			}
		}
		// max x
<span class="nc bnc" id="L513" title="All 4 branches missed.">		if (ray.origin.x &gt;= box.max.x &amp;&amp; ray.direction.x &lt; 0) {</span>
<span class="nc" id="L514">			t = (box.max.x - ray.origin.x) / ray.direction.x;</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">			if (t &gt;= 0) {</span>
<span class="nc" id="L516">				v2.set(ray.direction).scl(t).add(ray.origin);</span>
<span class="nc bnc" id="L517" title="All 12 branches missed.">				if (v2.y &gt;= box.min.y &amp;&amp; v2.y &lt;= box.max.y &amp;&amp; v2.z &gt;= box.min.z &amp;&amp; v2.z &lt;= box.max.z &amp;&amp; (!hit || t &lt; lowest)) {</span>
<span class="nc" id="L518">					hit = true;</span>
<span class="nc" id="L519">					lowest = t;</span>
				}
			}
		}
		// min y
<span class="nc bnc" id="L524" title="All 4 branches missed.">		if (ray.origin.y &lt;= box.min.y &amp;&amp; ray.direction.y &gt; 0) {</span>
<span class="nc" id="L525">			t = (box.min.y - ray.origin.y) / ray.direction.y;</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">			if (t &gt;= 0) {</span>
<span class="nc" id="L527">				v2.set(ray.direction).scl(t).add(ray.origin);</span>
<span class="nc bnc" id="L528" title="All 12 branches missed.">				if (v2.x &gt;= box.min.x &amp;&amp; v2.x &lt;= box.max.x &amp;&amp; v2.z &gt;= box.min.z &amp;&amp; v2.z &lt;= box.max.z &amp;&amp; (!hit || t &lt; lowest)) {</span>
<span class="nc" id="L529">					hit = true;</span>
<span class="nc" id="L530">					lowest = t;</span>
				}
			}
		}
		// max y
<span class="nc bnc" id="L535" title="All 4 branches missed.">		if (ray.origin.y &gt;= box.max.y &amp;&amp; ray.direction.y &lt; 0) {</span>
<span class="nc" id="L536">			t = (box.max.y - ray.origin.y) / ray.direction.y;</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">			if (t &gt;= 0) {</span>
<span class="nc" id="L538">				v2.set(ray.direction).scl(t).add(ray.origin);</span>
<span class="nc bnc" id="L539" title="All 12 branches missed.">				if (v2.x &gt;= box.min.x &amp;&amp; v2.x &lt;= box.max.x &amp;&amp; v2.z &gt;= box.min.z &amp;&amp; v2.z &lt;= box.max.z &amp;&amp; (!hit || t &lt; lowest)) {</span>
<span class="nc" id="L540">					hit = true;</span>
<span class="nc" id="L541">					lowest = t;</span>
				}
			}
		}
		// min z
<span class="nc bnc" id="L546" title="All 4 branches missed.">		if (ray.origin.z &lt;= box.min.z &amp;&amp; ray.direction.z &gt; 0) {</span>
<span class="nc" id="L547">			t = (box.min.z - ray.origin.z) / ray.direction.z;</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">			if (t &gt;= 0) {</span>
<span class="nc" id="L549">				v2.set(ray.direction).scl(t).add(ray.origin);</span>
<span class="nc bnc" id="L550" title="All 12 branches missed.">				if (v2.x &gt;= box.min.x &amp;&amp; v2.x &lt;= box.max.x &amp;&amp; v2.y &gt;= box.min.y &amp;&amp; v2.y &lt;= box.max.y &amp;&amp; (!hit || t &lt; lowest)) {</span>
<span class="nc" id="L551">					hit = true;</span>
<span class="nc" id="L552">					lowest = t;</span>
				}
			}
		}
		// max y
<span class="nc bnc" id="L557" title="All 4 branches missed.">		if (ray.origin.z &gt;= box.max.z &amp;&amp; ray.direction.z &lt; 0) {</span>
<span class="nc" id="L558">			t = (box.max.z - ray.origin.z) / ray.direction.z;</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">			if (t &gt;= 0) {</span>
<span class="nc" id="L560">				v2.set(ray.direction).scl(t).add(ray.origin);</span>
<span class="nc bnc" id="L561" title="All 12 branches missed.">				if (v2.x &gt;= box.min.x &amp;&amp; v2.x &lt;= box.max.x &amp;&amp; v2.y &gt;= box.min.y &amp;&amp; v2.y &lt;= box.max.y &amp;&amp; (!hit || t &lt; lowest)) {</span>
<span class="nc" id="L562">					hit = true;</span>
<span class="nc" id="L563">					lowest = t;</span>
				}
			}
		}
<span class="nc bnc" id="L567" title="All 4 branches missed.">		if (hit &amp;&amp; intersection != null) {</span>
<span class="nc" id="L568">			intersection.set(ray.direction).scl(lowest).add(ray.origin);</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">			if (intersection.x &lt; box.min.x) {</span>
<span class="nc" id="L570">				intersection.x = box.min.x;</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">			} else if (intersection.x &gt; box.max.x) {</span>
<span class="nc" id="L572">				intersection.x = box.max.x;</span>
			}
<span class="nc bnc" id="L574" title="All 2 branches missed.">			if (intersection.y &lt; box.min.y) {</span>
<span class="nc" id="L575">				intersection.y = box.min.y;</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">			} else if (intersection.y &gt; box.max.y) {</span>
<span class="nc" id="L577">				intersection.y = box.max.y;</span>
			}
<span class="nc bnc" id="L579" title="All 2 branches missed.">			if (intersection.z &lt; box.min.z) {</span>
<span class="nc" id="L580">				intersection.z = box.min.z;</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">			} else if (intersection.z &gt; box.max.z) {</span>
<span class="nc" id="L582">				intersection.z = box.max.z;</span>
			}
		}
<span class="nc" id="L585">		return hit;</span>
	}

	/** Quick check whether the given {@link Ray} and {@link BoundingBox} intersect.
	 * 
	 * @param ray The ray
	 * @param box The bounding box
	 * @return Whether the ray and the bounding box intersect. */
	static public boolean intersectRayBoundsFast (Ray ray, BoundingBox box) {
<span class="nc" id="L594">		return intersectRayBoundsFast(ray, box.getCenter(tmp1), box.getDimensions(tmp2));</span>
	}

	/** Quick check whether the given {@link Ray} and {@link BoundingBox} intersect.
	 * 
	 * @param ray The ray
	 * @param center The center of the bounding box
	 * @param dimensions The dimensions (width, height and depth) of the bounding box
	 * @return Whether the ray and the bounding box intersect. */
	static public boolean intersectRayBoundsFast (Ray ray, Vector3 center, Vector3 dimensions) {
<span class="nc" id="L604">		final float divX = 1f / ray.direction.x;</span>
<span class="nc" id="L605">		final float divY = 1f / ray.direction.y;</span>
<span class="nc" id="L606">		final float divZ = 1f / ray.direction.z;</span>

<span class="nc" id="L608">		float minx = ((center.x - dimensions.x * .5f) - ray.origin.x) * divX;</span>
<span class="nc" id="L609">		float maxx = ((center.x + dimensions.x * .5f) - ray.origin.x) * divX;</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">		if (minx &gt; maxx) {</span>
<span class="nc" id="L611">			final float t = minx;</span>
<span class="nc" id="L612">			minx = maxx;</span>
<span class="nc" id="L613">			maxx = t;</span>
		}

<span class="nc" id="L616">		float miny = ((center.y - dimensions.y * .5f) - ray.origin.y) * divY;</span>
<span class="nc" id="L617">		float maxy = ((center.y + dimensions.y * .5f) - ray.origin.y) * divY;</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">		if (miny &gt; maxy) {</span>
<span class="nc" id="L619">			final float t = miny;</span>
<span class="nc" id="L620">			miny = maxy;</span>
<span class="nc" id="L621">			maxy = t;</span>
		}

<span class="nc" id="L624">		float minz = ((center.z - dimensions.z * .5f) - ray.origin.z) * divZ;</span>
<span class="nc" id="L625">		float maxz = ((center.z + dimensions.z * .5f) - ray.origin.z) * divZ;</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">		if (minz &gt; maxz) {</span>
<span class="nc" id="L627">			final float t = minz;</span>
<span class="nc" id="L628">			minz = maxz;</span>
<span class="nc" id="L629">			maxz = t;</span>
		}

<span class="nc" id="L632">		float min = Math.max(Math.max(minx, miny), minz);</span>
<span class="nc" id="L633">		float max = Math.min(Math.min(maxx, maxy), maxz);</span>

<span class="nc bnc" id="L635" title="All 4 branches missed.">		return max &gt;= 0 &amp;&amp; max &gt;= min;</span>
	}

<span class="fc" id="L638">	static Vector3 best = new Vector3();</span>
<span class="fc" id="L639">	static Vector3 tmp = new Vector3();</span>
<span class="fc" id="L640">	static Vector3 tmp1 = new Vector3();</span>
<span class="fc" id="L641">	static Vector3 tmp2 = new Vector3();</span>
<span class="fc" id="L642">	static Vector3 tmp3 = new Vector3();</span>
<span class="fc" id="L643">	static Vector2 v2tmp = new Vector2();</span>

	/** Intersects the given ray with list of triangles. Returns the nearest intersection point in intersection
	 * 
	 * @param ray The ray
	 * @param triangles The triangles, each successive 9 elements are the 3 vertices of a triangle, a vertex is made of 3
	 *           successive floats (XYZ)
	 * @param intersection The nearest intersection point (optional)
	 * @return Whether the ray and the triangles intersect. */
	public static boolean intersectRayTriangles (Ray ray, float[] triangles, Vector3 intersection) {
<span class="nc" id="L653">		float min_dist = Float.MAX_VALUE;</span>
<span class="nc" id="L654">		boolean hit = false;</span>

<span class="nc bnc" id="L656" title="All 2 branches missed.">		if (triangles.length % 9 != 0) throw new RuntimeException(&quot;triangles array size is not a multiple of 9&quot;);</span>

<span class="nc bnc" id="L658" title="All 2 branches missed.">		for (int i = 0; i &lt; triangles.length; i += 9) {</span>
<span class="nc" id="L659">			boolean result = intersectRayTriangle(ray, tmp1.set(triangles[i], triangles[i + 1], triangles[i + 2]),</span>
<span class="nc" id="L660">				tmp2.set(triangles[i + 3], triangles[i + 4], triangles[i + 5]),</span>
<span class="nc" id="L661">				tmp3.set(triangles[i + 6], triangles[i + 7], triangles[i + 8]), tmp);</span>

<span class="nc bnc" id="L663" title="All 2 branches missed.">			if (result) {</span>
<span class="nc" id="L664">				float dist = ray.origin.dst2(tmp);</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">				if (dist &lt; min_dist) {</span>
<span class="nc" id="L666">					min_dist = dist;</span>
<span class="nc" id="L667">					best.set(tmp);</span>
<span class="nc" id="L668">					hit = true;</span>
				}
			}
		}

<span class="nc bnc" id="L673" title="All 2 branches missed.">		if (!hit)</span>
<span class="nc" id="L674">			return false;</span>
		else {
<span class="nc bnc" id="L676" title="All 2 branches missed.">			if (intersection != null) intersection.set(best);</span>
<span class="nc" id="L677">			return true;</span>
		}
	}

	/** Intersects the given ray with list of triangles. Returns the nearest intersection point in intersection
	 * 
	 * @param ray The ray
	 * @param vertices the vertices
	 * @param indices the indices, each successive 3 shorts index the 3 vertices of a triangle
	 * @param vertexSize the size of a vertex in floats
	 * @param intersection The nearest intersection point (optional)
	 * @return Whether the ray and the triangles intersect. */
	public static boolean intersectRayTriangles (Ray ray, float[] vertices, short[] indices, int vertexSize,
		Vector3 intersection) {
<span class="nc" id="L691">		float min_dist = Float.MAX_VALUE;</span>
<span class="nc" id="L692">		boolean hit = false;</span>

<span class="nc bnc" id="L694" title="All 2 branches missed.">		if (indices.length % 3 != 0) throw new RuntimeException(&quot;triangle list size is not a multiple of 3&quot;);</span>

<span class="nc bnc" id="L696" title="All 2 branches missed.">		for (int i = 0; i &lt; indices.length; i += 3) {</span>
<span class="nc" id="L697">			int i1 = indices[i] * vertexSize;</span>
<span class="nc" id="L698">			int i2 = indices[i + 1] * vertexSize;</span>
<span class="nc" id="L699">			int i3 = indices[i + 2] * vertexSize;</span>

<span class="nc" id="L701">			boolean result = intersectRayTriangle(ray, tmp1.set(vertices[i1], vertices[i1 + 1], vertices[i1 + 2]),</span>
<span class="nc" id="L702">				tmp2.set(vertices[i2], vertices[i2 + 1], vertices[i2 + 2]),</span>
<span class="nc" id="L703">				tmp3.set(vertices[i3], vertices[i3 + 1], vertices[i3 + 2]), tmp);</span>

<span class="nc bnc" id="L705" title="All 2 branches missed.">			if (result) {</span>
<span class="nc" id="L706">				float dist = ray.origin.dst2(tmp);</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">				if (dist &lt; min_dist) {</span>
<span class="nc" id="L708">					min_dist = dist;</span>
<span class="nc" id="L709">					best.set(tmp);</span>
<span class="nc" id="L710">					hit = true;</span>
				}
			}
		}

<span class="nc bnc" id="L715" title="All 2 branches missed.">		if (!hit)</span>
<span class="nc" id="L716">			return false;</span>
		else {
<span class="nc bnc" id="L718" title="All 2 branches missed.">			if (intersection != null) intersection.set(best);</span>
<span class="nc" id="L719">			return true;</span>
		}
	}

	/** Intersects the given ray with list of triangles. Returns the nearest intersection point in intersection
	 * 
	 * @param ray The ray
	 * @param triangles The triangles, each successive 3 elements are the 3 vertices of a triangle
	 * @param intersection The nearest intersection point (optional)
	 * @return Whether the ray and the triangles intersect. */
	public static boolean intersectRayTriangles (Ray ray, List&lt;Vector3&gt; triangles, Vector3 intersection) {
<span class="nc" id="L730">		float min_dist = Float.MAX_VALUE;</span>
<span class="nc" id="L731">		boolean hit = false;</span>

<span class="nc bnc" id="L733" title="All 2 branches missed.">		if (triangles.size() % 3 != 0) throw new RuntimeException(&quot;triangle list size is not a multiple of 3&quot;);</span>

<span class="nc bnc" id="L735" title="All 2 branches missed.">		for (int i = 0; i &lt; triangles.size(); i += 3) {</span>
<span class="nc" id="L736">			boolean result = intersectRayTriangle(ray, triangles.get(i), triangles.get(i + 1), triangles.get(i + 2), tmp);</span>

<span class="nc bnc" id="L738" title="All 2 branches missed.">			if (result) {</span>
<span class="nc" id="L739">				float dist = ray.origin.dst2(tmp);</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">				if (dist &lt; min_dist) {</span>
<span class="nc" id="L741">					min_dist = dist;</span>
<span class="nc" id="L742">					best.set(tmp);</span>
<span class="nc" id="L743">					hit = true;</span>
				}
			}
		}

<span class="nc bnc" id="L748" title="All 2 branches missed.">		if (!hit)</span>
<span class="nc" id="L749">			return false;</span>
		else {
<span class="nc bnc" id="L751" title="All 2 branches missed.">			if (intersection != null) intersection.set(best);</span>
<span class="nc" id="L752">			return true;</span>
		}
	}

	/** Intersects the two lines and returns the intersection point in intersection.
	 * 
	 * @param p1 The first point of the first line
	 * @param p2 The second point of the first line
	 * @param p3 The first point of the second line
	 * @param p4 The second point of the second line
	 * @param intersection The intersection point. May be null.
	 * @return Whether the two lines intersect */
	public static boolean intersectLines (Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 intersection) {
<span class="nc" id="L765">		float x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y, x3 = p3.x, y3 = p3.y, x4 = p4.x, y4 = p4.y;</span>

<span class="nc" id="L767">		float d = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">		if (d == 0) return false;</span>

<span class="nc bnc" id="L770" title="All 2 branches missed.">		if (intersection != null) {</span>
<span class="nc" id="L771">			float ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / d;</span>
<span class="nc" id="L772">			intersection.set(x1 + (x2 - x1) * ua, y1 + (y2 - y1) * ua);</span>
		}
<span class="nc" id="L774">		return true;</span>
	}

	/** Intersects the two lines and returns the intersection point in intersection.
	 * @param intersection The intersection point, or null.
	 * @return Whether the two lines intersect */
	public static boolean intersectLines (float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4,
		Vector2 intersection) {
<span class="nc" id="L782">		float d = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">		if (d == 0) return false;</span>

<span class="nc bnc" id="L785" title="All 2 branches missed.">		if (intersection != null) {</span>
<span class="nc" id="L786">			float ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / d;</span>
<span class="nc" id="L787">			intersection.set(x1 + (x2 - x1) * ua, y1 + (y2 - y1) * ua);</span>
		}
<span class="nc" id="L789">		return true;</span>
	}

	/** Check whether the given line and {@link Polygon} intersect.
	 * @param p1 The first point of the line
	 * @param p2 The second point of the line
	 * @param polygon The polygon
	 * @return Whether polygon and line intersects */
	public static boolean intersectLinePolygon (Vector2 p1, Vector2 p2, Polygon polygon) {
<span class="nc" id="L798">		float[] vertices = polygon.getTransformedVertices();</span>
<span class="nc" id="L799">		float x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y;</span>
<span class="nc" id="L800">		int n = vertices.length;</span>
<span class="nc" id="L801">		float x3 = vertices[n - 2], y3 = vertices[n - 1];</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">		for (int i = 0; i &lt; n; i += 2) {</span>
<span class="nc" id="L803">			float x4 = vertices[i], y4 = vertices[i + 1];</span>
<span class="nc" id="L804">			float d = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">			if (d != 0) {</span>
<span class="nc" id="L806">				float yd = y1 - y3;</span>
<span class="nc" id="L807">				float xd = x1 - x3;</span>
<span class="nc" id="L808">				float ua = ((x4 - x3) * yd - (y4 - y3) * xd) / d;</span>
<span class="nc bnc" id="L809" title="All 4 branches missed.">				if (ua &gt;= 0 &amp;&amp; ua &lt;= 1) {</span>
<span class="nc" id="L810">					return true;</span>
				}
			}
<span class="nc" id="L813">			x3 = x4;</span>
<span class="nc" id="L814">			y3 = y4;</span>
		}
<span class="nc" id="L816">		return false;</span>
	}

	/** Determines whether the given rectangles intersect and, if they do, sets the supplied {@code intersection} rectangle to the
	 * area of overlap.
	 * @return Whether the rectangles intersect */
	static public boolean intersectRectangles (Rectangle rectangle1, Rectangle rectangle2, Rectangle intersection) {
<span class="nc bnc" id="L823" title="All 2 branches missed.">		if (rectangle1.overlaps(rectangle2)) {</span>
<span class="nc" id="L824">			intersection.x = Math.max(rectangle1.x, rectangle2.x);</span>
<span class="nc" id="L825">			intersection.width = Math.min(rectangle1.x + rectangle1.width, rectangle2.x + rectangle2.width) - intersection.x;</span>
<span class="nc" id="L826">			intersection.y = Math.max(rectangle1.y, rectangle2.y);</span>
<span class="nc" id="L827">			intersection.height = Math.min(rectangle1.y + rectangle1.height, rectangle2.y + rectangle2.height) - intersection.y;</span>
<span class="nc" id="L828">			return true;</span>
		}
<span class="nc" id="L830">		return false;</span>
	}

	/** Determines whether the given rectangle and segment intersect
	 * @param startX x-coordinate start of line segment
	 * @param startY y-coordinate start of line segment
	 * @param endX y-coordinate end of line segment
	 * @param endY y-coordinate end of line segment
	 * @param rectangle rectangle that is being tested for collision
	 * @return whether the rectangle intersects with the line segment */
	public static boolean intersectSegmentRectangle (float startX, float startY, float endX, float endY, Rectangle rectangle) {
<span class="nc" id="L841">		float rectangleEndX = rectangle.x + rectangle.width;</span>
<span class="nc" id="L842">		float rectangleEndY = rectangle.y + rectangle.height;</span>

<span class="nc bnc" id="L844" title="All 2 branches missed.">		if (intersectSegments(startX, startY, endX, endY, rectangle.x, rectangle.y, rectangle.x, rectangleEndY, null)) return true;</span>

<span class="nc bnc" id="L846" title="All 2 branches missed.">		if (intersectSegments(startX, startY, endX, endY, rectangle.x, rectangle.y, rectangleEndX, rectangle.y, null)) return true;</span>

<span class="nc bnc" id="L848" title="All 2 branches missed.">		if (intersectSegments(startX, startY, endX, endY, rectangleEndX, rectangle.y, rectangleEndX, rectangleEndY, null))</span>
<span class="nc" id="L849">			return true;</span>

<span class="nc bnc" id="L851" title="All 2 branches missed.">		if (intersectSegments(startX, startY, endX, endY, rectangle.x, rectangleEndY, rectangleEndX, rectangleEndY, null))</span>
<span class="nc" id="L852">			return true;</span>

<span class="nc" id="L854">		return rectangle.contains(startX, startY);</span>
	}

	/** {@link #intersectSegmentRectangle(float, float, float, float, Rectangle)} */
	public static boolean intersectSegmentRectangle (Vector2 start, Vector2 end, Rectangle rectangle) {
<span class="nc" id="L859">		return intersectSegmentRectangle(start.x, start.y, end.x, end.y, rectangle);</span>
	}

	/** Check whether the given line segment and {@link Polygon} intersect.
	 * @param p1 The first point of the segment
	 * @param p2 The second point of the segment
	 * @return Whether polygon and segment intersect */
	public static boolean intersectSegmentPolygon (Vector2 p1, Vector2 p2, Polygon polygon) {
<span class="nc" id="L867">		float[] vertices = polygon.getTransformedVertices();</span>
<span class="nc" id="L868">		float x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y;</span>
<span class="nc" id="L869">		int n = vertices.length;</span>
<span class="nc" id="L870">		float x3 = vertices[n - 2], y3 = vertices[n - 1];</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">		for (int i = 0; i &lt; n; i += 2) {</span>
<span class="nc" id="L872">			float x4 = vertices[i], y4 = vertices[i + 1];</span>
<span class="nc" id="L873">			float d = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);</span>
<span class="nc bnc" id="L874" title="All 2 branches missed.">			if (d != 0) {</span>
<span class="nc" id="L875">				float yd = y1 - y3;</span>
<span class="nc" id="L876">				float xd = x1 - x3;</span>
<span class="nc" id="L877">				float ua = ((x4 - x3) * yd - (y4 - y3) * xd) / d;</span>
<span class="nc bnc" id="L878" title="All 4 branches missed.">				if (ua &gt;= 0 &amp;&amp; ua &lt;= 1) {</span>
<span class="nc" id="L879">					float ub = ((x2 - x1) * yd - (y2 - y1) * xd) / d;</span>
<span class="nc bnc" id="L880" title="All 4 branches missed.">					if (ub &gt;= 0 &amp;&amp; ub &lt;= 1) {</span>
<span class="nc" id="L881">						return true;</span>
					}
				}
			}
<span class="nc" id="L885">			x3 = x4;</span>
<span class="nc" id="L886">			y3 = y4;</span>
		}
<span class="nc" id="L888">		return false;</span>
	}

	/** Intersects the two line segments and returns the intersection point in intersection.
	 * 
	 * @param p1 The first point of the first line segment
	 * @param p2 The second point of the first line segment
	 * @param p3 The first point of the second line segment
	 * @param p4 The second point of the second line segment
	 * @param intersection The intersection point. May be null.
	 * @return Whether the two line segments intersect */
	public static boolean intersectSegments (Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 intersection) {
<span class="nc" id="L900">		float x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y, x3 = p3.x, y3 = p3.y, x4 = p4.x, y4 = p4.y;</span>

<span class="nc" id="L902">		float d = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);</span>
<span class="nc bnc" id="L903" title="All 2 branches missed.">		if (d == 0) return false;</span>

<span class="nc" id="L905">		float yd = y1 - y3;</span>
<span class="nc" id="L906">		float xd = x1 - x3;</span>
<span class="nc" id="L907">		float ua = ((x4 - x3) * yd - (y4 - y3) * xd) / d;</span>
<span class="nc bnc" id="L908" title="All 4 branches missed.">		if (ua &lt; 0 || ua &gt; 1) return false;</span>

<span class="nc" id="L910">		float ub = ((x2 - x1) * yd - (y2 - y1) * xd) / d;</span>
<span class="nc bnc" id="L911" title="All 4 branches missed.">		if (ub &lt; 0 || ub &gt; 1) return false;</span>

<span class="nc bnc" id="L913" title="All 2 branches missed.">		if (intersection != null) intersection.set(x1 + (x2 - x1) * ua, y1 + (y2 - y1) * ua);</span>
<span class="nc" id="L914">		return true;</span>
	}

	/** @param intersection May be null. */
	public static boolean intersectSegments (float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4,
		Vector2 intersection) {
<span class="nc" id="L920">		float d = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">		if (d == 0) return false;</span>

<span class="nc" id="L923">		float yd = y1 - y3;</span>
<span class="nc" id="L924">		float xd = x1 - x3;</span>
<span class="nc" id="L925">		float ua = ((x4 - x3) * yd - (y4 - y3) * xd) / d;</span>
<span class="nc bnc" id="L926" title="All 4 branches missed.">		if (ua &lt; 0 || ua &gt; 1) return false;</span>

<span class="nc" id="L928">		float ub = ((x2 - x1) * yd - (y2 - y1) * xd) / d;</span>
<span class="nc bnc" id="L929" title="All 4 branches missed.">		if (ub &lt; 0 || ub &gt; 1) return false;</span>

<span class="nc bnc" id="L931" title="All 2 branches missed.">		if (intersection != null) intersection.set(x1 + (x2 - x1) * ua, y1 + (y2 - y1) * ua);</span>
<span class="nc" id="L932">		return true;</span>
	}

	static float det (float a, float b, float c, float d) {
<span class="nc" id="L936">		return a * d - b * c;</span>
	}

	static double detd (double a, double b, double c, double d) {
<span class="nc" id="L940">		return a * d - b * c;</span>
	}

	public static boolean overlaps (Circle c1, Circle c2) {
<span class="nc" id="L944">		return c1.overlaps(c2);</span>
	}

	public static boolean overlaps (Rectangle r1, Rectangle r2) {
<span class="nc" id="L948">		return r1.overlaps(r2);</span>
	}

	public static boolean overlaps (Circle c, Rectangle r) {
<span class="nc" id="L952">		float closestX = c.x;</span>
<span class="nc" id="L953">		float closestY = c.y;</span>

<span class="nc bnc" id="L955" title="All 2 branches missed.">		if (c.x &lt; r.x) {</span>
<span class="nc" id="L956">			closestX = r.x;</span>
<span class="nc bnc" id="L957" title="All 2 branches missed.">		} else if (c.x &gt; r.x + r.width) {</span>
<span class="nc" id="L958">			closestX = r.x + r.width;</span>
		}

<span class="nc bnc" id="L961" title="All 2 branches missed.">		if (c.y &lt; r.y) {</span>
<span class="nc" id="L962">			closestY = r.y;</span>
<span class="nc bnc" id="L963" title="All 2 branches missed.">		} else if (c.y &gt; r.y + r.height) {</span>
<span class="nc" id="L964">			closestY = r.y + r.height;</span>
		}

<span class="nc" id="L967">		closestX = closestX - c.x;</span>
<span class="nc" id="L968">		closestX *= closestX;</span>
<span class="nc" id="L969">		closestY = closestY - c.y;</span>
<span class="nc" id="L970">		closestY *= closestY;</span>

<span class="nc bnc" id="L972" title="All 2 branches missed.">		return closestX + closestY &lt; c.radius * c.radius;</span>
	}

	/** Check whether specified counter-clockwise wound convex polygons overlap.
	 * @param p1 The first polygon.
	 * @param p2 The second polygon.
	 * @return Whether polygons overlap. */
	public static boolean overlapConvexPolygons (Polygon p1, Polygon p2) {
<span class="nc" id="L980">		return overlapConvexPolygons(p1, p2, null);</span>
	}

	/** Check whether specified counter-clockwise wound convex polygons overlap. If they do, optionally obtain a Minimum
	 * Translation Vector indicating the minimum magnitude vector required to push the polygon p1 out of collision with polygon p2.
	 * @param p1 The first polygon.
	 * @param p2 The second polygon.
	 * @param mtv A Minimum Translation Vector to fill in the case of a collision, or null (optional).
	 * @return Whether polygons overlap. */
	public static boolean overlapConvexPolygons (Polygon p1, Polygon p2, MinimumTranslationVector mtv) {
<span class="nc" id="L990">		return overlapConvexPolygons(p1.getTransformedVertices(), p2.getTransformedVertices(), mtv);</span>
	}

	/** @see #overlapConvexPolygons(float[], int, int, float[], int, int, MinimumTranslationVector) */
	public static boolean overlapConvexPolygons (float[] verts1, float[] verts2, MinimumTranslationVector mtv) {
<span class="nc" id="L995">		return overlapConvexPolygons(verts1, 0, verts1.length, verts2, 0, verts2.length, mtv);</span>
	}

	/** Check whether polygons defined by the given counter-clockwise wound vertex arrays overlap. If they do, optionally obtain a
	 * Minimum Translation Vector indicating the minimum magnitude vector required to push the polygon defined by verts1 out of the
	 * collision with the polygon defined by verts2.
	 * @param verts1 Vertices of the first polygon.
	 * @param verts2 Vertices of the second polygon.
	 * @param mtv A Minimum Translation Vector to fill in the case of a collision, or null (optional).
	 * @return Whether polygons overlap. */
	public static boolean overlapConvexPolygons (float[] verts1, int offset1, int count1, float[] verts2, int offset2, int count2,
		MinimumTranslationVector mtv) {
<span class="nc" id="L1007">		float overlap = Float.MAX_VALUE;</span>
<span class="nc" id="L1008">		float smallestAxisX = 0;</span>
<span class="nc" id="L1009">		float smallestAxisY = 0;</span>
		int numInNormalDir;

<span class="nc" id="L1012">		int end1 = offset1 + count1;</span>
<span class="nc" id="L1013">		int end2 = offset2 + count2;</span>

		// Get polygon1 axes
<span class="nc bnc" id="L1016" title="All 2 branches missed.">		for (int i = offset1; i &lt; end1; i += 2) {</span>
<span class="nc" id="L1017">			float x1 = verts1[i];</span>
<span class="nc" id="L1018">			float y1 = verts1[i + 1];</span>
<span class="nc" id="L1019">			float x2 = verts1[(i + 2) % count1];</span>
<span class="nc" id="L1020">			float y2 = verts1[(i + 3) % count1];</span>

<span class="nc" id="L1022">			float axisX = y1 - y2;</span>
<span class="nc" id="L1023">			float axisY = -(x1 - x2);</span>

<span class="nc" id="L1025">			final float length = (float)Math.sqrt(axisX * axisX + axisY * axisY);</span>
<span class="nc" id="L1026">			axisX /= length;</span>
<span class="nc" id="L1027">			axisY /= length;</span>

			// -- Begin check for separation on this axis --//

			// Project polygon1 onto this axis
<span class="nc" id="L1032">			float min1 = axisX * verts1[0] + axisY * verts1[1];</span>
<span class="nc" id="L1033">			float max1 = min1;</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">			for (int j = offset1; j &lt; end1; j += 2) {</span>
<span class="nc" id="L1035">				float p = axisX * verts1[j] + axisY * verts1[j + 1];</span>
<span class="nc bnc" id="L1036" title="All 2 branches missed.">				if (p &lt; min1) {</span>
<span class="nc" id="L1037">					min1 = p;</span>
<span class="nc bnc" id="L1038" title="All 2 branches missed.">				} else if (p &gt; max1) {</span>
<span class="nc" id="L1039">					max1 = p;</span>
				}
			}

			// Project polygon2 onto this axis
<span class="nc" id="L1044">			numInNormalDir = 0;</span>
<span class="nc" id="L1045">			float min2 = axisX * verts2[0] + axisY * verts2[1];</span>
<span class="nc" id="L1046">			float max2 = min2;</span>
<span class="nc bnc" id="L1047" title="All 2 branches missed.">			for (int j = offset2; j &lt; end2; j += 2) {</span>
				// Counts the number of points that are within the projected area.
<span class="nc" id="L1049">				numInNormalDir -= pointLineSide(x1, y1, x2, y2, verts2[j], verts2[j + 1]);</span>
<span class="nc" id="L1050">				float p = axisX * verts2[j] + axisY * verts2[j + 1];</span>
<span class="nc bnc" id="L1051" title="All 2 branches missed.">				if (p &lt; min2) {</span>
<span class="nc" id="L1052">					min2 = p;</span>
<span class="nc bnc" id="L1053" title="All 2 branches missed.">				} else if (p &gt; max2) {</span>
<span class="nc" id="L1054">					max2 = p;</span>
				}
			}

<span class="nc bnc" id="L1058" title="All 8 branches missed.">			if (!(min1 &lt;= min2 &amp;&amp; max1 &gt;= min2 || min2 &lt;= min1 &amp;&amp; max2 &gt;= min1)) {</span>
<span class="nc" id="L1059">				return false;</span>
			} else {
<span class="nc" id="L1061">				float o = Math.min(max1, max2) - Math.max(min1, min2);</span>
<span class="nc bnc" id="L1062" title="All 8 branches missed.">				if (min1 &lt; min2 &amp;&amp; max1 &gt; max2 || min2 &lt; min1 &amp;&amp; max2 &gt; max1) {</span>
<span class="nc" id="L1063">					float mins = Math.abs(min1 - min2);</span>
<span class="nc" id="L1064">					float maxs = Math.abs(max1 - max2);</span>
<span class="nc bnc" id="L1065" title="All 2 branches missed.">					if (mins &lt; maxs) {</span>
<span class="nc" id="L1066">						o += mins;</span>
					} else {
<span class="nc" id="L1068">						o += maxs;</span>
					}
				}
<span class="nc bnc" id="L1071" title="All 2 branches missed.">				if (o &lt; overlap) {</span>
<span class="nc" id="L1072">					overlap = o;</span>
					// Adjusts the direction based on the number of points found
<span class="nc bnc" id="L1074" title="All 2 branches missed.">					smallestAxisX = numInNormalDir &gt;= 0 ? axisX : -axisX;</span>
<span class="nc bnc" id="L1075" title="All 2 branches missed.">					smallestAxisY = numInNormalDir &gt;= 0 ? axisY : -axisY;</span>
				}
			}
			// -- End check for separation on this axis --//
		}

		// Get polygon2 axes
<span class="nc bnc" id="L1082" title="All 2 branches missed.">		for (int i = offset2; i &lt; end2; i += 2) {</span>
<span class="nc" id="L1083">			float x1 = verts2[i];</span>
<span class="nc" id="L1084">			float y1 = verts2[i + 1];</span>
<span class="nc" id="L1085">			float x2 = verts2[(i + 2) % count2];</span>
<span class="nc" id="L1086">			float y2 = verts2[(i + 3) % count2];</span>

<span class="nc" id="L1088">			float axisX = y1 - y2;</span>
<span class="nc" id="L1089">			float axisY = -(x1 - x2);</span>

<span class="nc" id="L1091">			final float length = (float)Math.sqrt(axisX * axisX + axisY * axisY);</span>
<span class="nc" id="L1092">			axisX /= length;</span>
<span class="nc" id="L1093">			axisY /= length;</span>

			// -- Begin check for separation on this axis --//
<span class="nc" id="L1096">			numInNormalDir = 0;</span>

			// Project polygon1 onto this axis
<span class="nc" id="L1099">			float min1 = axisX * verts1[0] + axisY * verts1[1];</span>
<span class="nc" id="L1100">			float max1 = min1;</span>
<span class="nc bnc" id="L1101" title="All 2 branches missed.">			for (int j = offset1; j &lt; end1; j += 2) {</span>
<span class="nc" id="L1102">				float p = axisX * verts1[j] + axisY * verts1[j + 1];</span>
				// Counts the number of points that are within the projected area.
<span class="nc" id="L1104">				numInNormalDir -= pointLineSide(x1, y1, x2, y2, verts1[j], verts1[j + 1]);</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">				if (p &lt; min1) {</span>
<span class="nc" id="L1106">					min1 = p;</span>
<span class="nc bnc" id="L1107" title="All 2 branches missed.">				} else if (p &gt; max1) {</span>
<span class="nc" id="L1108">					max1 = p;</span>
				}
			}

			// Project polygon2 onto this axis
<span class="nc" id="L1113">			float min2 = axisX * verts2[0] + axisY * verts2[1];</span>
<span class="nc" id="L1114">			float max2 = min2;</span>
<span class="nc bnc" id="L1115" title="All 2 branches missed.">			for (int j = offset2; j &lt; end2; j += 2) {</span>
<span class="nc" id="L1116">				float p = axisX * verts2[j] + axisY * verts2[j + 1];</span>
<span class="nc bnc" id="L1117" title="All 2 branches missed.">				if (p &lt; min2) {</span>
<span class="nc" id="L1118">					min2 = p;</span>
<span class="nc bnc" id="L1119" title="All 2 branches missed.">				} else if (p &gt; max2) {</span>
<span class="nc" id="L1120">					max2 = p;</span>
				}
			}

<span class="nc bnc" id="L1124" title="All 8 branches missed.">			if (!(min1 &lt;= min2 &amp;&amp; max1 &gt;= min2 || min2 &lt;= min1 &amp;&amp; max2 &gt;= min1)) {</span>
<span class="nc" id="L1125">				return false;</span>
			} else {
<span class="nc" id="L1127">				float o = Math.min(max1, max2) - Math.max(min1, min2);</span>

<span class="nc bnc" id="L1129" title="All 8 branches missed.">				if (min1 &lt; min2 &amp;&amp; max1 &gt; max2 || min2 &lt; min1 &amp;&amp; max2 &gt; max1) {</span>
<span class="nc" id="L1130">					float mins = Math.abs(min1 - min2);</span>
<span class="nc" id="L1131">					float maxs = Math.abs(max1 - max2);</span>
<span class="nc bnc" id="L1132" title="All 2 branches missed.">					if (mins &lt; maxs) {</span>
<span class="nc" id="L1133">						o += mins;</span>
					} else {
<span class="nc" id="L1135">						o += maxs;</span>
					}
				}

<span class="nc bnc" id="L1139" title="All 2 branches missed.">				if (o &lt; overlap) {</span>
<span class="nc" id="L1140">					overlap = o;</span>
					// Adjusts the direction based on the number of points found
<span class="nc bnc" id="L1142" title="All 2 branches missed.">					smallestAxisX = numInNormalDir &lt; 0 ? axisX : -axisX;</span>
<span class="nc bnc" id="L1143" title="All 2 branches missed.">					smallestAxisY = numInNormalDir &lt; 0 ? axisY : -axisY;</span>
				}
			}
			// -- End check for separation on this axis --//
		}
<span class="nc bnc" id="L1148" title="All 2 branches missed.">		if (mtv != null) {</span>
<span class="nc" id="L1149">			mtv.normal.set(smallestAxisX, smallestAxisY);</span>
<span class="nc" id="L1150">			mtv.depth = overlap;</span>
		}
<span class="nc" id="L1152">		return true;</span>
	}

	/** Splits the triangle by the plane. The result is stored in the SplitTriangle instance. Depending on where the triangle is
	 * relative to the plane, the result can be:
	 * 
	 * &lt;ul&gt;
	 * &lt;li&gt;Triangle is fully in front/behind: {@link SplitTriangle#front} or {@link SplitTriangle#back} will contain the original
	 * triangle, {@link SplitTriangle#total} will be one.&lt;/li&gt;
	 * &lt;li&gt;Triangle has two vertices in front, one behind: {@link SplitTriangle#front} contains 2 triangles,
	 * {@link SplitTriangle#back} contains 1 triangles, {@link SplitTriangle#total} will be 3.&lt;/li&gt;
	 * &lt;li&gt;Triangle has one vertex in front, two behind: {@link SplitTriangle#front} contains 1 triangle,
	 * {@link SplitTriangle#back} contains 2 triangles, {@link SplitTriangle#total} will be 3.&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * The input triangle should have the form: x, y, z, x2, y2, z2, x3, y3, z3. One can add additional attributes per vertex which
	 * will be interpolated if split, such as texture coordinates or normals. Note that these additional attributes won't be
	 * normalized, as might be necessary in case of normals.
	 * 
	 * @param triangle
	 * @param plane
	 * @param split output SplitTriangle */
	public static void splitTriangle (float[] triangle, Plane plane, SplitTriangle split) {
<span class="fc" id="L1175">		int stride = triangle.length / 3;</span>
<span class="fc bfc" id="L1176" title="All 2 branches covered.">		boolean r1 = plane.testPoint(triangle[0], triangle[1], triangle[2]) == PlaneSide.Back;</span>
<span class="fc bfc" id="L1177" title="All 2 branches covered.">		boolean r2 = plane.testPoint(triangle[0 + stride], triangle[1 + stride], triangle[2 + stride]) == PlaneSide.Back;</span>
<span class="fc bfc" id="L1178" title="All 2 branches covered.">		boolean r3 = plane.testPoint(triangle[0 + stride * 2], triangle[1 + stride * 2],</span>
			triangle[2 + stride * 2]) == PlaneSide.Back;

<span class="fc" id="L1181">		split.reset();</span>

		// easy case, triangle is on one side (point on plane means front).
<span class="pc bpc" id="L1184" title="1 of 4 branches missed.">		if (r1 == r2 &amp;&amp; r2 == r3) {</span>
<span class="fc" id="L1185">			split.total = 1;</span>
<span class="fc bfc" id="L1186" title="All 2 branches covered.">			if (r1) {</span>
<span class="fc" id="L1187">				split.numBack = 1;</span>
<span class="fc" id="L1188">				System.arraycopy(triangle, 0, split.back, 0, triangle.length);</span>
			} else {
<span class="fc" id="L1190">				split.numFront = 1;</span>
<span class="fc" id="L1191">				System.arraycopy(triangle, 0, split.front, 0, triangle.length);</span>
			}
<span class="fc" id="L1193">			return;</span>
		}

		// set number of triangles
<span class="fc" id="L1197">		split.total = 3;</span>
<span class="fc bfc" id="L1198" title="All 6 branches covered.">		split.numFront = (r1 ? 0 : 1) + (r2 ? 0 : 1) + (r3 ? 0 : 1);</span>
<span class="fc" id="L1199">		split.numBack = split.total - split.numFront;</span>

		// hard case, split the three edges on the plane
		// determine which array to fill first, front or back, flip if we
		// cross the plane
<span class="fc bfc" id="L1204" title="All 2 branches covered.">		split.setSide(!r1);</span>

		// split first edge
<span class="fc" id="L1207">		int first = 0;</span>
<span class="fc" id="L1208">		int second = stride;</span>
<span class="pc bpc" id="L1209" title="1 of 2 branches missed.">		if (r1 != r2) {</span>
			// split the edge
<span class="fc" id="L1211">			splitEdge(triangle, first, second, stride, plane, split.edgeSplit, 0);</span>

			// add first edge vertex and new vertex to current side
<span class="fc" id="L1214">			split.add(triangle, first, stride);</span>
<span class="fc" id="L1215">			split.add(split.edgeSplit, 0, stride);</span>

			// flip side and add new vertex and second edge vertex to current side
<span class="fc bfc" id="L1218" title="All 2 branches covered.">			split.setSide(!split.getSide());</span>
<span class="fc" id="L1219">			split.add(split.edgeSplit, 0, stride);</span>
		} else {
			// add both vertices
<span class="nc" id="L1222">			split.add(triangle, first, stride);</span>
		}

		// split second edge
<span class="fc" id="L1226">		first = stride;</span>
<span class="fc" id="L1227">		second = stride + stride;</span>
<span class="pc bpc" id="L1228" title="1 of 2 branches missed.">		if (r2 != r3) {</span>
			// split the edge
<span class="fc" id="L1230">			splitEdge(triangle, first, second, stride, plane, split.edgeSplit, 0);</span>

			// add first edge vertex and new vertex to current side
<span class="fc" id="L1233">			split.add(triangle, first, stride);</span>
<span class="fc" id="L1234">			split.add(split.edgeSplit, 0, stride);</span>

			// flip side and add new vertex and second edge vertex to current side
<span class="fc bfc" id="L1237" title="All 2 branches covered.">			split.setSide(!split.getSide());</span>
<span class="fc" id="L1238">			split.add(split.edgeSplit, 0, stride);</span>
		} else {
			// add both vertices
<span class="nc" id="L1241">			split.add(triangle, first, stride);</span>
		}

		// split third edge
<span class="fc" id="L1245">		first = stride + stride;</span>
<span class="fc" id="L1246">		second = 0;</span>
<span class="pc bpc" id="L1247" title="1 of 2 branches missed.">		if (r3 != r1) {</span>
			// split the edge
<span class="nc" id="L1249">			splitEdge(triangle, first, second, stride, plane, split.edgeSplit, 0);</span>

			// add first edge vertex and new vertex to current side
<span class="nc" id="L1252">			split.add(triangle, first, stride);</span>
<span class="nc" id="L1253">			split.add(split.edgeSplit, 0, stride);</span>

			// flip side and add new vertex and second edge vertex to current side
<span class="nc bnc" id="L1256" title="All 2 branches missed.">			split.setSide(!split.getSide());</span>
<span class="nc" id="L1257">			split.add(split.edgeSplit, 0, stride);</span>
		} else {
			// add both vertices
<span class="fc" id="L1260">			split.add(triangle, first, stride);</span>
		}

		// triangulate the side with 2 triangles
<span class="fc bfc" id="L1264" title="All 2 branches covered.">		if (split.numFront == 2) {</span>
<span class="fc" id="L1265">			System.arraycopy(split.front, stride * 2, split.front, stride * 3, stride * 2);</span>
<span class="fc" id="L1266">			System.arraycopy(split.front, 0, split.front, stride * 5, stride);</span>
		} else {
<span class="fc" id="L1268">			System.arraycopy(split.back, stride * 2, split.back, stride * 3, stride * 2);</span>
<span class="fc" id="L1269">			System.arraycopy(split.back, 0, split.back, stride * 5, stride);</span>
		}
<span class="fc" id="L1271">	}</span>

<span class="fc" id="L1273">	static Vector3 intersection = new Vector3();</span>

	private static void splitEdge (float[] vertices, int s, int e, int stride, Plane plane, float[] split, int offset) {
<span class="fc" id="L1276">		float t = Intersector.intersectLinePlane(vertices[s], vertices[s + 1], vertices[s + 2], vertices[e], vertices[e + 1],</span>
			vertices[e + 2], plane, intersection);
<span class="fc" id="L1278">		split[offset + 0] = intersection.x;</span>
<span class="fc" id="L1279">		split[offset + 1] = intersection.y;</span>
<span class="fc" id="L1280">		split[offset + 2] = intersection.z;</span>
<span class="pc bpc" id="L1281" title="1 of 2 branches missed.">		for (int i = 3; i &lt; stride; i++) {</span>
<span class="nc" id="L1282">			float a = vertices[s + i];</span>
<span class="nc" id="L1283">			float b = vertices[e + i];</span>
<span class="nc" id="L1284">			split[offset + i] = a + t * (b - a);</span>
		}
<span class="fc" id="L1286">	}</span>

	public static class SplitTriangle {
		public float[] front;
		public float[] back;
		float[] edgeSplit;
		public int numFront;
		public int numBack;
		public int total;
<span class="fc" id="L1295">		boolean frontCurrent = false;</span>
<span class="fc" id="L1296">		int frontOffset = 0;</span>
<span class="fc" id="L1297">		int backOffset = 0;</span>

		/** Creates a new instance, assuming numAttributes attributes per triangle vertex.
		 * @param numAttributes must be &gt;= 3 */
<span class="fc" id="L1301">		public SplitTriangle (int numAttributes) {</span>
<span class="fc" id="L1302">			front = new float[numAttributes * 3 * 2];</span>
<span class="fc" id="L1303">			back = new float[numAttributes * 3 * 2];</span>
<span class="fc" id="L1304">			edgeSplit = new float[numAttributes];</span>
<span class="fc" id="L1305">		}</span>

		@Override
		public String toString () {
<span class="nc" id="L1309">			return &quot;SplitTriangle [front=&quot; + Arrays.toString(front) + &quot;, back=&quot; + Arrays.toString(back) + &quot;, numFront=&quot; + numFront</span>
				+ &quot;, numBack=&quot; + numBack + &quot;, total=&quot; + total + &quot;]&quot;;
		}

		void setSide (boolean front) {
<span class="fc" id="L1314">			frontCurrent = front;</span>
<span class="fc" id="L1315">		}</span>

		boolean getSide () {
<span class="fc" id="L1318">			return frontCurrent;</span>
		}

		void add (float[] vertex, int offset, int stride) {
<span class="fc bfc" id="L1322" title="All 2 branches covered.">			if (frontCurrent) {</span>
<span class="fc" id="L1323">				System.arraycopy(vertex, offset, front, frontOffset, stride);</span>
<span class="fc" id="L1324">				frontOffset += stride;</span>
			} else {
<span class="fc" id="L1326">				System.arraycopy(vertex, offset, back, backOffset, stride);</span>
<span class="fc" id="L1327">				backOffset += stride;</span>
			}
<span class="fc" id="L1329">		}</span>

		void reset () {
<span class="fc" id="L1332">			frontCurrent = false;</span>
<span class="fc" id="L1333">			frontOffset = 0;</span>
<span class="fc" id="L1334">			backOffset = 0;</span>
<span class="fc" id="L1335">			numFront = 0;</span>
<span class="fc" id="L1336">			numBack = 0;</span>
<span class="fc" id="L1337">			total = 0;</span>
<span class="fc" id="L1338">		}</span>
	}

	/** Minimum translation required to separate two polygons. */
<span class="nc" id="L1342">	public static class MinimumTranslationVector {</span>
		/** Unit length vector that indicates the direction for the separation */
<span class="nc" id="L1344">		public Vector2 normal = new Vector2();</span>
		/** Distance of the translation required for the separation */
<span class="nc" id="L1346">		public float depth = 0;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>