<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Mesh.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">gdx</a> &gt; <a href="index.source.html" class="el_package">com.badlogic.gdx.graphics</a> &gt; <span class="el_source">Mesh.java</span></div><h1>Mesh.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2011 See AUTHORS file.
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

package com.badlogic.gdx.graphics;

import java.nio.FloatBuffer;
import java.nio.ShortBuffer;
import java.util.HashMap;
import java.util.Map;

import com.badlogic.gdx.Application;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.VertexAttributes.Usage;
import com.badlogic.gdx.graphics.glutils.IndexArray;
import com.badlogic.gdx.graphics.glutils.IndexBufferObject;
import com.badlogic.gdx.graphics.glutils.IndexBufferObjectSubData;
import com.badlogic.gdx.graphics.glutils.IndexData;
import com.badlogic.gdx.graphics.glutils.InstanceBufferObject;
import com.badlogic.gdx.graphics.glutils.InstanceData;
import com.badlogic.gdx.graphics.glutils.ShaderProgram;
import com.badlogic.gdx.graphics.glutils.VertexArray;
import com.badlogic.gdx.graphics.glutils.VertexBufferObject;
import com.badlogic.gdx.graphics.glutils.VertexBufferObjectSubData;
import com.badlogic.gdx.graphics.glutils.VertexBufferObjectWithVAO;
import com.badlogic.gdx.graphics.glutils.VertexData;
import com.badlogic.gdx.math.Matrix3;
import com.badlogic.gdx.math.Matrix4;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.math.collision.BoundingBox;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.Disposable;
import com.badlogic.gdx.utils.GdxRuntimeException;

/** &lt;p&gt;
 * A Mesh holds vertices composed of attributes specified by a {@link VertexAttributes} instance. The vertices are held either in
 * VRAM in form of vertex buffer objects or in RAM in form of vertex arrays. The former variant is more performant and is
 * preferred over vertex arrays if hardware supports it.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * Meshes are automatically managed. If the OpenGL context is lost all vertex buffer objects get invalidated and must be reloaded
 * when the context is recreated. This only happens on Android when a user switches to another application or receives an incoming
 * call. A managed Mesh will be reloaded automagically so you don't have to do this manually.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * A Mesh consists of vertices and optionally indices which specify which vertices define a triangle. Each vertex is composed of
 * attributes such as position, normal, color or texture coordinate. Note that not all of this attributes must be given, except
 * for position which is non-optional. Each attribute has an alias which is used when rendering a Mesh in OpenGL ES 2.0. The alias
 * is used to bind a specific vertex attribute to a shader attribute. The shader source and the alias of the attribute must match
 * exactly for this to work.
 * &lt;/p&gt;
 *
 * @author mzechner, Dave Clayton &lt;contact@redskyforge.com&gt;, Xoppa */
public class Mesh implements Disposable {
<span class="nc" id="L70">	public enum VertexDataType {</span>
<span class="nc" id="L71">		VertexArray, VertexBufferObject, VertexBufferObjectSubData, VertexBufferObjectWithVAO</span>
	}

	/** list of all meshes **/
<span class="nc" id="L75">	static final Map&lt;Application, Array&lt;Mesh&gt;&gt; meshes = new HashMap&lt;Application, Array&lt;Mesh&gt;&gt;();</span>

	final VertexData vertices;
	final IndexData indices;
<span class="nc" id="L79">	boolean autoBind = true;</span>
	final boolean isVertexArray;

	InstanceData instances;
<span class="nc" id="L83">	boolean isInstanced = false;</span>

<span class="nc" id="L85">	protected Mesh (VertexData vertices, IndexData indices, boolean isVertexArray) {</span>
<span class="nc" id="L86">		this.vertices = vertices;</span>
<span class="nc" id="L87">		this.indices = indices;</span>
<span class="nc" id="L88">		this.isVertexArray = isVertexArray;</span>

<span class="nc" id="L90">		addManagedMesh(Gdx.app, this);</span>
<span class="nc" id="L91">	}</span>

	/** Creates a new Mesh with the given attributes.
	 *
	 * @param isStatic whether this mesh is static or not. Allows for internal optimizations.
	 * @param maxVertices the maximum number of vertices this mesh can hold
	 * @param maxIndices the maximum number of indices this mesh can hold
	 * @param attributes the {@link VertexAttribute}s. Each vertex attribute defines one property of a vertex such as position,
	 *           normal or texture coordinate */
<span class="nc" id="L100">	public Mesh (boolean isStatic, int maxVertices, int maxIndices, VertexAttribute... attributes) {</span>
<span class="nc" id="L101">		vertices = makeVertexBuffer(isStatic, maxVertices, new VertexAttributes(attributes));</span>
<span class="nc" id="L102">		indices = new IndexBufferObject(isStatic, maxIndices);</span>
<span class="nc" id="L103">		isVertexArray = false;</span>

<span class="nc" id="L105">		addManagedMesh(Gdx.app, this);</span>
<span class="nc" id="L106">	}</span>

	/** Creates a new Mesh with the given attributes.
	 *
	 * @param isStatic whether this mesh is static or not. Allows for internal optimizations.
	 * @param maxVertices the maximum number of vertices this mesh can hold
	 * @param maxIndices the maximum number of indices this mesh can hold
	 * @param attributes the {@link VertexAttributes}. Each vertex attribute defines one property of a vertex such as position,
	 *           normal or texture coordinate */
<span class="nc" id="L115">	public Mesh (boolean isStatic, int maxVertices, int maxIndices, VertexAttributes attributes) {</span>
<span class="nc" id="L116">		vertices = makeVertexBuffer(isStatic, maxVertices, attributes);</span>
<span class="nc" id="L117">		indices = new IndexBufferObject(isStatic, maxIndices);</span>
<span class="nc" id="L118">		isVertexArray = false;</span>

<span class="nc" id="L120">		addManagedMesh(Gdx.app, this);</span>
<span class="nc" id="L121">	}</span>

	/** Creates a new Mesh with the given attributes. Adds extra optimizations for dynamic (frequently modified) meshes.
	 *
	 * @param staticVertices whether vertices of this mesh are static or not. Allows for internal optimizations.
	 * @param staticIndices whether indices of this mesh are static or not. Allows for internal optimizations.
	 * @param maxVertices the maximum number of vertices this mesh can hold
	 * @param maxIndices the maximum number of indices this mesh can hold
	 * @param attributes the {@link VertexAttributes}. Each vertex attribute defines one property of a vertex such as position,
	 *           normal or texture coordinate
	 *
	 * @author Jaroslaw Wisniewski &lt;j.wisniewski@appsisle.com&gt; **/
<span class="nc" id="L133">	public Mesh (boolean staticVertices, boolean staticIndices, int maxVertices, int maxIndices, VertexAttributes attributes) {</span>
<span class="nc" id="L134">		vertices = makeVertexBuffer(staticVertices, maxVertices, attributes);</span>
<span class="nc" id="L135">		indices = new IndexBufferObject(staticIndices, maxIndices);</span>
<span class="nc" id="L136">		isVertexArray = false;</span>

<span class="nc" id="L138">		addManagedMesh(Gdx.app, this);</span>
<span class="nc" id="L139">	}</span>

	private VertexData makeVertexBuffer (boolean isStatic, int maxVertices, VertexAttributes vertexAttributes) {
<span class="nc bnc" id="L142" title="All 2 branches missed.">		if (Gdx.gl30 != null) {</span>
<span class="nc" id="L143">			return new VertexBufferObjectWithVAO(isStatic, maxVertices, vertexAttributes);</span>
		} else {
<span class="nc" id="L145">			return new VertexBufferObject(isStatic, maxVertices, vertexAttributes);</span>
		}
	}

	/** Creates a new Mesh with the given attributes. This is an expert method with no error checking. Use at your own risk.
	 *
	 * @param type the {@link VertexDataType} to be used, VBO or VA.
	 * @param isStatic whether this mesh is static or not. Allows for internal optimizations.
	 * @param maxVertices the maximum number of vertices this mesh can hold
	 * @param maxIndices the maximum number of indices this mesh can hold
	 * @param attributes the {@link VertexAttribute}s. Each vertex attribute defines one property of a vertex such as position,
	 *           normal or texture coordinate */
	public Mesh (VertexDataType type, boolean isStatic, int maxVertices, int maxIndices, VertexAttribute... attributes) {
<span class="nc" id="L158">		this(type, isStatic, maxVertices, maxIndices, new VertexAttributes(attributes));</span>
<span class="nc" id="L159">	}</span>

	/** Creates a new Mesh with the given attributes. This is an expert method with no error checking. Use at your own risk.
	 *
	 * @param type the {@link VertexDataType} to be used, VBO or VA.
	 * @param isStatic whether this mesh is static or not. Allows for internal optimizations.
	 * @param maxVertices the maximum number of vertices this mesh can hold
	 * @param maxIndices the maximum number of indices this mesh can hold
	 * @param attributes the {@link VertexAttributes}. */
<span class="nc" id="L168">	public Mesh (VertexDataType type, boolean isStatic, int maxVertices, int maxIndices, VertexAttributes attributes) {</span>
<span class="nc bnc" id="L169" title="All 4 branches missed.">		switch (type) {</span>
		case VertexBufferObject:
<span class="nc" id="L171">			vertices = new VertexBufferObject(isStatic, maxVertices, attributes);</span>
<span class="nc" id="L172">			indices = new IndexBufferObject(isStatic, maxIndices);</span>
<span class="nc" id="L173">			isVertexArray = false;</span>
<span class="nc" id="L174">			break;</span>
		case VertexBufferObjectSubData:
<span class="nc" id="L176">			vertices = new VertexBufferObjectSubData(isStatic, maxVertices, attributes);</span>
<span class="nc" id="L177">			indices = new IndexBufferObjectSubData(isStatic, maxIndices);</span>
<span class="nc" id="L178">			isVertexArray = false;</span>
<span class="nc" id="L179">			break;</span>
		case VertexBufferObjectWithVAO:
<span class="nc" id="L181">			vertices = new VertexBufferObjectWithVAO(isStatic, maxVertices, attributes);</span>
<span class="nc" id="L182">			indices = new IndexBufferObjectSubData(isStatic, maxIndices);</span>
<span class="nc" id="L183">			isVertexArray = false;</span>
<span class="nc" id="L184">			break;</span>
		case VertexArray:
		default:
<span class="nc" id="L187">			vertices = new VertexArray(maxVertices, attributes);</span>
<span class="nc" id="L188">			indices = new IndexArray(maxIndices);</span>
<span class="nc" id="L189">			isVertexArray = true;</span>
			break;
		}

<span class="nc" id="L193">		addManagedMesh(Gdx.app, this);</span>
<span class="nc" id="L194">	}</span>

	public Mesh enableInstancedRendering (boolean isStatic, int maxInstances, VertexAttribute... attributes) {
<span class="nc bnc" id="L197" title="All 2 branches missed.">		if (!isInstanced) {</span>
<span class="nc" id="L198">			isInstanced = true;</span>
<span class="nc" id="L199">			instances = new InstanceBufferObject(isStatic, maxInstances, attributes);</span>
		} else {
<span class="nc" id="L201">			throw new GdxRuntimeException(&quot;Trying to enable InstancedRendering on same Mesh instance twice.&quot;</span>
				+ &quot; Use disableInstancedRendering to clean up old InstanceData first&quot;);
		}
<span class="nc" id="L204">		return this;</span>
	}

	public Mesh disableInstancedRendering () {
<span class="nc bnc" id="L208" title="All 2 branches missed.">		if (isInstanced) {</span>
<span class="nc" id="L209">			isInstanced = false;</span>
<span class="nc" id="L210">			instances.dispose();</span>
<span class="nc" id="L211">			instances = null;</span>
		}
<span class="nc" id="L213">		return this;</span>
	}

	/** Sets the instance data of this Mesh. The attributes are assumed to be given in float format.
	 *
	 * @param instanceData the instance data.
	 * @param offset the offset into the vertices array
	 * @param count the number of floats to use
	 * @return the mesh for invocation chaining. */
	public Mesh setInstanceData (float[] instanceData, int offset, int count) {
<span class="nc bnc" id="L223" title="All 2 branches missed.">		if (instances != null) {</span>
<span class="nc" id="L224">			this.instances.setInstanceData(instanceData, offset, count);</span>
		} else {
<span class="nc" id="L226">			throw new GdxRuntimeException(&quot;An InstanceBufferObject must be set before setting instance data!&quot;);</span>
		}
<span class="nc" id="L228">		return this;</span>
	}

	/** Sets the instance data of this Mesh. The attributes are assumed to be given in float format.
	 *
	 * @param instanceData the instance data.
	 * @return the mesh for invocation chaining. */
	public Mesh setInstanceData (float[] instanceData) {
<span class="nc bnc" id="L236" title="All 2 branches missed.">		if (instances != null) {</span>
<span class="nc" id="L237">			this.instances.setInstanceData(instanceData, 0, instanceData.length);</span>
		} else {
<span class="nc" id="L239">			throw new GdxRuntimeException(&quot;An InstanceBufferObject must be set before setting instance data!&quot;);</span>
		}
<span class="nc" id="L241">		return this;</span>
	}

	/** Sets the instance data of this Mesh. The attributes are assumed to be given in float format.
	 *
	 * @param instanceData the instance data.
	 * @param count the number of floats to use
	 * @return the mesh for invocation chaining. */
	public Mesh setInstanceData (FloatBuffer instanceData, int count) {
<span class="nc bnc" id="L250" title="All 2 branches missed.">		if (instances != null) {</span>
<span class="nc" id="L251">			this.instances.setInstanceData(instanceData, count);</span>
		} else {
<span class="nc" id="L253">			throw new GdxRuntimeException(&quot;An InstanceBufferObject must be set before setting instance data!&quot;);</span>
		}
<span class="nc" id="L255">		return this;</span>
	}

	/** Sets the instance data of this Mesh. The attributes are assumed to be given in float format.
	 *
	 * @param instanceData the instance data.
	 * @return the mesh for invocation chaining. */
	public Mesh setInstanceData (FloatBuffer instanceData) {
<span class="nc bnc" id="L263" title="All 2 branches missed.">		if (instances != null) {</span>
<span class="nc" id="L264">			this.instances.setInstanceData(instanceData, instanceData.limit());</span>
		} else {
<span class="nc" id="L266">			throw new GdxRuntimeException(&quot;An InstanceBufferObject must be set before setting instance data!&quot;);</span>
		}

<span class="nc" id="L269">		return this;</span>
	}

	/** Update (a portion of) the instance data. Does not resize the backing buffer.
	 * @param targetOffset the offset in number of floats of the mesh part.
	 * @param source the instance data to update the mesh part with */
	public Mesh updateInstanceData (int targetOffset, float[] source) {
<span class="nc" id="L276">		return updateInstanceData(targetOffset, source, 0, source.length);</span>
	}

	/** Update (a portion of) the instance data. Does not resize the backing buffer.
	 * @param targetOffset the offset in number of floats of the mesh part.
	 * @param source the instance data to update the mesh part with
	 * @param sourceOffset the offset in number of floats within the source array
	 * @param count the number of floats to update */
	public Mesh updateInstanceData (int targetOffset, float[] source, int sourceOffset, int count) {
<span class="nc" id="L285">		this.instances.updateInstanceData(targetOffset, source, sourceOffset, count);</span>
<span class="nc" id="L286">		return this;</span>
	}

	/** Update (a portion of) the instance data. Does not resize the backing buffer.
	 * @param targetOffset the offset in number of floats of the mesh part.
	 * @param source the instance data to update the mesh part with */
	public Mesh updateInstanceData (int targetOffset, FloatBuffer source) {
<span class="nc" id="L293">		return updateInstanceData(targetOffset, source, 0, source.limit());</span>
	}

	/** Update (a portion of) the instance data. Does not resize the backing buffer.
	 * @param targetOffset the offset in number of floats of the mesh part.
	 * @param source the instance data to update the mesh part with
	 * @param sourceOffset the offset in number of floats within the source array
	 * @param count the number of floats to update */
	public Mesh updateInstanceData (int targetOffset, FloatBuffer source, int sourceOffset, int count) {
<span class="nc" id="L302">		this.instances.updateInstanceData(targetOffset, source, sourceOffset, count);</span>
<span class="nc" id="L303">		return this;</span>
	}

	/** Sets the vertices of this Mesh. The attributes are assumed to be given in float format.
	 *
	 * @param vertices the vertices.
	 * @return the mesh for invocation chaining. */
	public Mesh setVertices (float[] vertices) {
<span class="nc" id="L311">		this.vertices.setVertices(vertices, 0, vertices.length);</span>

<span class="nc" id="L313">		return this;</span>
	}

	/** Sets the vertices of this Mesh. The attributes are assumed to be given in float format.
	 *
	 * @param vertices the vertices.
	 * @param offset the offset into the vertices array
	 * @param count the number of floats to use
	 * @return the mesh for invocation chaining. */
	public Mesh setVertices (float[] vertices, int offset, int count) {
<span class="nc" id="L323">		this.vertices.setVertices(vertices, offset, count);</span>

<span class="nc" id="L325">		return this;</span>
	}

	/** Update (a portion of) the vertices. Does not resize the backing buffer.
	 * @param targetOffset the offset in number of floats of the mesh part.
	 * @param source the vertex data to update the mesh part with */
	public Mesh updateVertices (int targetOffset, float[] source) {
<span class="nc" id="L332">		return updateVertices(targetOffset, source, 0, source.length);</span>
	}

	/** Update (a portion of) the vertices. Does not resize the backing buffer.
	 * @param targetOffset the offset in number of floats of the mesh part.
	 * @param source the vertex data to update the mesh part with
	 * @param sourceOffset the offset in number of floats within the source array
	 * @param count the number of floats to update */
	public Mesh updateVertices (int targetOffset, float[] source, int sourceOffset, int count) {
<span class="nc" id="L341">		this.vertices.updateVertices(targetOffset, source, sourceOffset, count);</span>
<span class="nc" id="L342">		return this;</span>
	}

	/** Copies the vertices from the Mesh to the float array. The float array must be large enough to hold all the Mesh's vertices.
	 * @param vertices the array to copy the vertices to */
	public float[] getVertices (float[] vertices) {
<span class="nc" id="L348">		return getVertices(0, -1, vertices);</span>
	}

	/** Copies the the remaining vertices from the Mesh to the float array. The float array must be large enough to hold the
	 * remaining vertices.
	 * @param srcOffset the offset (in number of floats) of the vertices in the mesh to copy
	 * @param vertices the array to copy the vertices to */
	public float[] getVertices (int srcOffset, float[] vertices) {
<span class="nc" id="L356">		return getVertices(srcOffset, -1, vertices);</span>
	}

	/** Copies the specified vertices from the Mesh to the float array. The float array must be large enough to hold count vertices.
	 * @param srcOffset the offset (in number of floats) of the vertices in the mesh to copy
	 * @param count the amount of floats to copy
	 * @param vertices the array to copy the vertices to */
	public float[] getVertices (int srcOffset, int count, float[] vertices) {
<span class="nc" id="L364">		return getVertices(srcOffset, count, vertices, 0);</span>
	}

	/** Copies the specified vertices from the Mesh to the float array. The float array must be large enough to hold
	 * destOffset+count vertices.
	 * @param srcOffset the offset (in number of floats) of the vertices in the mesh to copy
	 * @param count the amount of floats to copy
	 * @param vertices the array to copy the vertices to
	 * @param destOffset the offset (in floats) in the vertices array to start copying */
	public float[] getVertices (int srcOffset, int count, float[] vertices, int destOffset) {
		// TODO: Perhaps this method should be vertexSize aware??
<span class="nc" id="L375">		final int max = getNumVertices() * getVertexSize() / 4;</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">		if (count == -1) {</span>
<span class="nc" id="L377">			count = max - srcOffset;</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">			if (count &gt; vertices.length - destOffset) count = vertices.length - destOffset;</span>
		}
<span class="nc bnc" id="L380" title="All 10 branches missed.">		if (srcOffset &lt; 0 || count &lt;= 0 || (srcOffset + count) &gt; max || destOffset &lt; 0 || destOffset &gt;= vertices.length)</span>
<span class="nc" id="L381">			throw new IndexOutOfBoundsException();</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">		if ((vertices.length - destOffset) &lt; count)</span>
<span class="nc" id="L383">			throw new IllegalArgumentException(&quot;not enough room in vertices array, has &quot; + vertices.length + &quot; floats, needs &quot;</span>
				+ count);
<span class="nc" id="L385">		int pos = getVerticesBuffer().position();</span>
<span class="nc" id="L386">		getVerticesBuffer().position(srcOffset);</span>
<span class="nc" id="L387">		getVerticesBuffer().get(vertices, destOffset, count);</span>
<span class="nc" id="L388">		getVerticesBuffer().position(pos);</span>
<span class="nc" id="L389">		return vertices;</span>
	}

	/** Sets the indices of this Mesh
	 *
	 * @param indices the indices
	 * @return the mesh for invocation chaining. */
	public Mesh setIndices (short[] indices) {
<span class="nc" id="L397">		this.indices.setIndices(indices, 0, indices.length);</span>

<span class="nc" id="L399">		return this;</span>
	}

	/** Sets the indices of this Mesh.
	 *
	 * @param indices the indices
	 * @param offset the offset into the indices array
	 * @param count the number of indices to copy
	 * @return the mesh for invocation chaining. */
	public Mesh setIndices (short[] indices, int offset, int count) {
<span class="nc" id="L409">		this.indices.setIndices(indices, offset, count);</span>

<span class="nc" id="L411">		return this;</span>
	}

	/** Copies the indices from the Mesh to the short array. The short array must be large enough to hold all the Mesh's indices.
	 * @param indices the array to copy the indices to */
	public void getIndices (short[] indices) {
<span class="nc" id="L417">		getIndices(indices, 0);</span>
<span class="nc" id="L418">	}</span>

	/** Copies the indices from the Mesh to the short array. The short array must be large enough to hold destOffset + all the
	 * Mesh's indices.
	 * @param indices the array to copy the indices to
	 * @param destOffset the offset in the indices array to start copying */
	public void getIndices (short[] indices, int destOffset) {
<span class="nc" id="L425">		getIndices(0, indices, destOffset);</span>
<span class="nc" id="L426">	}</span>

	/** Copies the remaining indices from the Mesh to the short array. The short array must be large enough to hold destOffset + all
	 * the remaining indices.
	 * @param srcOffset the zero-based offset of the first index to fetch
	 * @param indices the array to copy the indices to
	 * @param destOffset the offset in the indices array to start copying */
	public void getIndices (int srcOffset, short[] indices, int destOffset) {
<span class="nc" id="L434">		getIndices(srcOffset, -1, indices, destOffset);</span>
<span class="nc" id="L435">	}</span>

	/** Copies the indices from the Mesh to the short array. The short array must be large enough to hold destOffset + count
	 * indices.
	 * @param srcOffset the zero-based offset of the first index to fetch
	 * @param count the total amount of indices to copy
	 * @param indices the array to copy the indices to
	 * @param destOffset the offset in the indices array to start copying */
	public void getIndices (int srcOffset, int count, short[] indices, int destOffset) {
<span class="nc" id="L444">		int max = getNumIndices();</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">		if (count &lt; 0) count = max - srcOffset;</span>
<span class="nc bnc" id="L446" title="All 6 branches missed.">		if (srcOffset &lt; 0 || srcOffset &gt;= max || srcOffset + count &gt; max)</span>
<span class="nc" id="L447">			throw new IllegalArgumentException(&quot;Invalid range specified, offset: &quot; + srcOffset + &quot;, count: &quot; + count + &quot;, max: &quot;</span>
				+ max);
<span class="nc bnc" id="L449" title="All 2 branches missed.">		if ((indices.length - destOffset) &lt; count)</span>
<span class="nc" id="L450">			throw new IllegalArgumentException(&quot;not enough room in indices array, has &quot; + indices.length + &quot; shorts, needs &quot; + count);</span>
<span class="nc" id="L451">		int pos = getIndicesBuffer().position();</span>
<span class="nc" id="L452">		getIndicesBuffer().position(srcOffset);</span>
<span class="nc" id="L453">		getIndicesBuffer().get(indices, destOffset, count);</span>
<span class="nc" id="L454">		getIndicesBuffer().position(pos);</span>
<span class="nc" id="L455">	}</span>

	/** @return the number of defined indices */
	public int getNumIndices () {
<span class="nc" id="L459">		return indices.getNumIndices();</span>
	}

	/** @return the number of defined vertices */
	public int getNumVertices () {
<span class="nc" id="L464">		return vertices.getNumVertices();</span>
	}

	/** @return the maximum number of vertices this mesh can hold */
	public int getMaxVertices () {
<span class="nc" id="L469">		return vertices.getNumMaxVertices();</span>
	}

	/** @return the maximum number of indices this mesh can hold */
	public int getMaxIndices () {
<span class="nc" id="L474">		return indices.getNumMaxIndices();</span>
	}

	/** @return the size of a single vertex in bytes */
	public int getVertexSize () {
<span class="nc" id="L479">		return vertices.getAttributes().vertexSize;</span>
	}

	/** Sets whether to bind the underlying {@link VertexArray} or {@link VertexBufferObject} automatically on a call to one of the
	 * render methods. Usually you want to use autobind. Manual binding is an expert functionality. There is a driver bug on the
	 * MSM720xa chips that will fuck up memory if you manipulate the vertices and indices of a Mesh multiple times while it is
	 * bound. Keep this in mind.
	 *
	 * @param autoBind whether to autobind meshes. */
	public void setAutoBind (boolean autoBind) {
<span class="nc" id="L489">		this.autoBind = autoBind;</span>
<span class="nc" id="L490">	}</span>

	/** Binds the underlying {@link VertexBufferObject} and {@link IndexBufferObject} if indices where given. Use this with OpenGL
	 * ES 2.0 and when auto-bind is disabled.
	 *
	 * @param shader the shader (does not bind the shader) */
	public void bind (final ShaderProgram shader) {
<span class="nc" id="L497">		bind(shader, null);</span>
<span class="nc" id="L498">	}</span>

	/** Binds the underlying {@link VertexBufferObject} and {@link IndexBufferObject} if indices where given. Use this with OpenGL
	 * ES 2.0 and when auto-bind is disabled.
	 *
	 * @param shader the shader (does not bind the shader)
	 * @param locations array containing the attribute locations. */
	public void bind (final ShaderProgram shader, final int[] locations) {
<span class="nc" id="L506">		vertices.bind(shader, locations);</span>
<span class="nc bnc" id="L507" title="All 4 branches missed.">		if (instances != null &amp;&amp; instances.getNumInstances() &gt; 0) instances.bind(shader, locations);</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">		if (indices.getNumIndices() &gt; 0) indices.bind();</span>
<span class="nc" id="L509">	}</span>

	/** Unbinds the underlying {@link VertexBufferObject} and {@link IndexBufferObject} is indices were given. Use this with OpenGL
	 * ES 1.x and when auto-bind is disabled.
	 *
	 * @param shader the shader (does not unbind the shader) */
	public void unbind (final ShaderProgram shader) {
<span class="nc" id="L516">		unbind(shader, null);</span>
<span class="nc" id="L517">	}</span>

	/** Unbinds the underlying {@link VertexBufferObject} and {@link IndexBufferObject} is indices were given. Use this with OpenGL
	 * ES 1.x and when auto-bind is disabled.
	 *
	 * @param shader the shader (does not unbind the shader)
	 * @param locations array containing the attribute locations. */
	public void unbind (final ShaderProgram shader, final int[] locations) {
<span class="nc" id="L525">		vertices.unbind(shader, locations);</span>
<span class="nc bnc" id="L526" title="All 4 branches missed.">		if (instances != null &amp;&amp; instances.getNumInstances() &gt; 0) instances.unbind(shader, locations);</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">		if (indices.getNumIndices() &gt; 0) indices.unbind();</span>
<span class="nc" id="L528">	}</span>

	/** &lt;p&gt;
	 * Renders the mesh using the given primitive type. If indices are set for this mesh then getNumIndices() / #vertices per
	 * primitive primitives are rendered. If no indices are set then getNumVertices() / #vertices per primitive are rendered.
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * This method will automatically bind each vertex attribute as specified at construction time via {@link VertexAttributes} to
	 * the respective shader attributes. The binding is based on the alias defined for each VertexAttribute.
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * This method must only be called after the {@link ShaderProgram#begin()} method has been called!
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * This method is intended for use with OpenGL ES 2.0 and will throw an IllegalStateException when OpenGL ES 1.x is used.
	 * &lt;/p&gt;
	 *
	 * @param primitiveType the primitive type */
	public void render (ShaderProgram shader, int primitiveType) {
<span class="nc bnc" id="L550" title="All 2 branches missed.">		render(shader, primitiveType, 0, indices.getNumMaxIndices() &gt; 0 ? getNumIndices() : getNumVertices(), autoBind);</span>
<span class="nc" id="L551">	}</span>

	/** &lt;p&gt;
	 * Renders the mesh using the given primitive type. offset specifies the offset into either the vertex buffer or the index
	 * buffer depending on whether indices are defined. count specifies the number of vertices or indices to use thus count /
	 * #vertices per primitive primitives are rendered.
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * This method will automatically bind each vertex attribute as specified at construction time via {@link VertexAttributes} to
	 * the respective shader attributes. The binding is based on the alias defined for each VertexAttribute.
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * This method must only be called after the {@link ShaderProgram#begin()} method has been called!
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * This method is intended for use with OpenGL ES 2.0 and will throw an IllegalStateException when OpenGL ES 1.x is used.
	 * &lt;/p&gt;
	 *
	 * @param shader the shader to be used
	 * @param primitiveType the primitive type
	 * @param offset the offset into the vertex or index buffer
	 * @param count number of vertices or indices to use */
	public void render (ShaderProgram shader, int primitiveType, int offset, int count) {
<span class="nc" id="L577">		render(shader, primitiveType, offset, count, autoBind);</span>
<span class="nc" id="L578">	}</span>

	/** &lt;p&gt;
	 * Renders the mesh using the given primitive type. offset specifies the offset into either the vertex buffer or the index
	 * buffer depending on whether indices are defined. count specifies the number of vertices or indices to use thus count /
	 * #vertices per primitive primitives are rendered.
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * This method will automatically bind each vertex attribute as specified at construction time via {@link VertexAttributes} to
	 * the respective shader attributes. The binding is based on the alias defined for each VertexAttribute.
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * This method must only be called after the {@link ShaderProgram#begin()} method has been called!
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * This method is intended for use with OpenGL ES 2.0 and will throw an IllegalStateException when OpenGL ES 1.x is used.
	 * &lt;/p&gt;
	 *
	 * @param shader the shader to be used
	 * @param primitiveType the primitive type
	 * @param offset the offset into the vertex or index buffer
	 * @param count number of vertices or indices to use
	 * @param autoBind overrides the autoBind member of this Mesh */
	public void render (ShaderProgram shader, int primitiveType, int offset, int count, boolean autoBind) {
<span class="nc bnc" id="L605" title="All 2 branches missed.">		if (count == 0) return;</span>

<span class="nc bnc" id="L607" title="All 2 branches missed.">		if (autoBind) bind(shader);</span>

<span class="nc bnc" id="L609" title="All 2 branches missed.">		if (isVertexArray) {</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">			if (indices.getNumIndices() &gt; 0) {</span>
<span class="nc" id="L611">				ShortBuffer buffer = indices.getBuffer();</span>
<span class="nc" id="L612">				int oldPosition = buffer.position();</span>
<span class="nc" id="L613">				int oldLimit = buffer.limit();</span>
<span class="nc" id="L614">				buffer.position(offset);</span>
<span class="nc" id="L615">				buffer.limit(offset + count);</span>
<span class="nc" id="L616">				Gdx.gl20.glDrawElements(primitiveType, count, GL20.GL_UNSIGNED_SHORT, buffer);</span>
<span class="nc" id="L617">				buffer.position(oldPosition);</span>
<span class="nc" id="L618">				buffer.limit(oldLimit);</span>
<span class="nc" id="L619">			} else {</span>
<span class="nc" id="L620">				Gdx.gl20.glDrawArrays(primitiveType, offset, count);</span>
			}
		} else {
<span class="nc" id="L623">			int numInstances = 0;</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">			if (isInstanced) numInstances = instances.getNumInstances();</span>

<span class="nc bnc" id="L626" title="All 2 branches missed.">			if (indices.getNumIndices() &gt; 0) {</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">				if (count + offset &gt; indices.getNumMaxIndices()) {</span>
<span class="nc" id="L628">					throw new GdxRuntimeException(&quot;Mesh attempting to access memory outside of the index buffer (count: &quot;</span>
<span class="nc" id="L629">						+ count + &quot;, offset: &quot; + offset + &quot;, max: &quot; + indices.getNumMaxIndices() + &quot;)&quot;);</span>
				}

<span class="nc bnc" id="L632" title="All 4 branches missed.">				if (isInstanced &amp;&amp; numInstances &gt; 0){</span>
<span class="nc" id="L633">					Gdx.gl30.glDrawElementsInstanced(primitiveType, count, GL20.GL_UNSIGNED_SHORT, offset * 2, numInstances);</span>
				} else {
<span class="nc" id="L635">					Gdx.gl20.glDrawElements(primitiveType, count, GL20.GL_UNSIGNED_SHORT, offset * 2);</span>
				}
			} else {
<span class="nc bnc" id="L638" title="All 4 branches missed.">				if (isInstanced &amp;&amp; numInstances &gt; 0){</span>
<span class="nc" id="L639">					Gdx.gl30.glDrawArraysInstanced(primitiveType, offset, count, numInstances);</span>
				} else {
<span class="nc" id="L641">					Gdx.gl20.glDrawArrays(primitiveType, offset, count);</span>
				}
			}
		}

<span class="nc bnc" id="L646" title="All 2 branches missed.">		if (autoBind) unbind(shader);</span>
<span class="nc" id="L647">	}</span>

	/** Frees all resources associated with this Mesh */
	public void dispose () {
<span class="nc bnc" id="L651" title="All 2 branches missed.">		if (meshes.get(Gdx.app) != null) meshes.get(Gdx.app).removeValue(this, true);</span>
<span class="nc" id="L652">		vertices.dispose();</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">		if (instances != null) instances.dispose();</span>
<span class="nc" id="L654">		indices.dispose();</span>
<span class="nc" id="L655">	}</span>

	/** Returns the first {@link VertexAttribute} having the given {@link Usage}.
	 * 
	 * @param usage the Usage.
	 * @return the VertexAttribute or null if no attribute with that usage was found. */
	public VertexAttribute getVertexAttribute (int usage) {
<span class="nc" id="L662">		VertexAttributes attributes = vertices.getAttributes();</span>
<span class="nc" id="L663">		int len = attributes.size();</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">		for (int i = 0; i &lt; len; i++)</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">			if (attributes.get(i).usage == usage) return attributes.get(i);</span>

<span class="nc" id="L667">		return null;</span>
	}

	/** @return the vertex attributes of this Mesh */
	public VertexAttributes getVertexAttributes () {
<span class="nc" id="L672">		return vertices.getAttributes();</span>
	}

	/** @return the backing FloatBuffer holding the vertices. Does not have to be a direct buffer on Android! */
	public FloatBuffer getVerticesBuffer () {
<span class="nc" id="L677">		return vertices.getBuffer();</span>
	}

	/** Calculates the {@link BoundingBox} of the vertices contained in this mesh. In case no vertices are defined yet a
	 * {@link GdxRuntimeException} is thrown. This method creates a new BoundingBox instance.
	 * 
	 * @return the bounding box. */
	public BoundingBox calculateBoundingBox () {
<span class="nc" id="L685">		BoundingBox bbox = new BoundingBox();</span>
<span class="nc" id="L686">		calculateBoundingBox(bbox);</span>
<span class="nc" id="L687">		return bbox;</span>
	}

	/** Calculates the {@link BoundingBox} of the vertices contained in this mesh. In case no vertices are defined yet a
	 * {@link GdxRuntimeException} is thrown.
	 * 
	 * @param bbox the bounding box to store the result in. */
	public void calculateBoundingBox (BoundingBox bbox) {
<span class="nc" id="L695">		final int numVertices = getNumVertices();</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">		if (numVertices == 0) throw new GdxRuntimeException(&quot;No vertices defined&quot;);</span>

<span class="nc" id="L698">		final FloatBuffer verts = vertices.getBuffer();</span>
<span class="nc" id="L699">		bbox.inf();</span>
<span class="nc" id="L700">		final VertexAttribute posAttrib = getVertexAttribute(Usage.Position);</span>
<span class="nc" id="L701">		final int offset = posAttrib.offset / 4;</span>
<span class="nc" id="L702">		final int vertexSize = vertices.getAttributes().vertexSize / 4;</span>
<span class="nc" id="L703">		int idx = offset;</span>

<span class="nc bnc" id="L705" title="All 4 branches missed.">		switch (posAttrib.numComponents) {</span>
		case 1:
<span class="nc bnc" id="L707" title="All 2 branches missed.">			for (int i = 0; i &lt; numVertices; i++) {</span>
<span class="nc" id="L708">				bbox.ext(verts.get(idx), 0, 0);</span>
<span class="nc" id="L709">				idx += vertexSize;</span>
			}
<span class="nc" id="L711">			break;</span>
		case 2:
<span class="nc bnc" id="L713" title="All 2 branches missed.">			for (int i = 0; i &lt; numVertices; i++) {</span>
<span class="nc" id="L714">				bbox.ext(verts.get(idx), verts.get(idx + 1), 0);</span>
<span class="nc" id="L715">				idx += vertexSize;</span>
			}
<span class="nc" id="L717">			break;</span>
		case 3:
<span class="nc bnc" id="L719" title="All 2 branches missed.">			for (int i = 0; i &lt; numVertices; i++) {</span>
<span class="nc" id="L720">				bbox.ext(verts.get(idx), verts.get(idx + 1), verts.get(idx + 2));</span>
<span class="nc" id="L721">				idx += vertexSize;</span>
			}
			break;
		}
<span class="nc" id="L725">	}</span>

	/** Calculate the {@link BoundingBox} of the specified part.
	 * @param out the bounding box to store the result in.
	 * @param offset the start index of the part.
	 * @param count the amount of indices the part contains.
	 * @return the value specified by out. */
	public BoundingBox calculateBoundingBox (final BoundingBox out, int offset, int count) {
<span class="nc" id="L733">		return extendBoundingBox(out.inf(), offset, count);</span>
	}

	/** Calculate the {@link BoundingBox} of the specified part.
	 * @param out the bounding box to store the result in.
	 * @param offset the start index of the part.
	 * @param count the amount of indices the part contains.
	 * @return the value specified by out. */
	public BoundingBox calculateBoundingBox (final BoundingBox out, int offset, int count, final Matrix4 transform) {
<span class="nc" id="L742">		return extendBoundingBox(out.inf(), offset, count, transform);</span>
	}

	/** Extends the specified {@link BoundingBox} with the specified part.
	 * @param out the bounding box to store the result in.
	 * @param offset the start index of the part.
	 * @param count the amount of indices the part contains.
	 * @return the value specified by out. */
	public BoundingBox extendBoundingBox (final BoundingBox out, int offset, int count) {
<span class="nc" id="L751">		return extendBoundingBox(out, offset, count, null);</span>
	}

<span class="nc" id="L754">	private final Vector3 tmpV = new Vector3();</span>

	/** Extends the specified {@link BoundingBox} with the specified part.
	 * @param out the bounding box to store the result in.
	 * @param offset the start of the part.
	 * @param count the size of the part.
	 * @return the value specified by out. */
	public BoundingBox extendBoundingBox (final BoundingBox out, int offset, int count, final Matrix4 transform) {
<span class="nc" id="L762">		final int numIndices = getNumIndices();</span>
<span class="nc" id="L763">		final int numVertices = getNumVertices();</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">		final int max = numIndices == 0 ? numVertices : numIndices;</span>
<span class="nc bnc" id="L765" title="All 6 branches missed.">		if (offset &lt; 0 || count &lt; 1 || offset + count &gt; max)</span>
<span class="nc" id="L766">			throw new GdxRuntimeException(&quot;Invalid part specified ( offset=&quot; + offset + &quot;, count=&quot; + count + &quot;, max=&quot; + max + &quot; )&quot;);</span>

<span class="nc" id="L768">		final FloatBuffer verts = vertices.getBuffer();</span>
<span class="nc" id="L769">		final ShortBuffer index = indices.getBuffer();</span>
<span class="nc" id="L770">		final VertexAttribute posAttrib = getVertexAttribute(Usage.Position);</span>
<span class="nc" id="L771">		final int posoff = posAttrib.offset / 4;</span>
<span class="nc" id="L772">		final int vertexSize = vertices.getAttributes().vertexSize / 4;</span>
<span class="nc" id="L773">		final int end = offset + count;</span>

<span class="nc bnc" id="L775" title="All 4 branches missed.">		switch (posAttrib.numComponents) {</span>
		case 1:
<span class="nc bnc" id="L777" title="All 2 branches missed.">			if (numIndices &gt; 0) {</span>
<span class="nc bnc" id="L778" title="All 2 branches missed.">				for (int i = offset; i &lt; end; i++) {</span>
<span class="nc" id="L779">					final int idx = index.get(i) * vertexSize + posoff;</span>
<span class="nc" id="L780">					tmpV.set(verts.get(idx), 0, 0);</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">					if (transform != null) tmpV.mul(transform);</span>
<span class="nc" id="L782">					out.ext(tmpV);</span>
				}
			} else {
<span class="nc bnc" id="L785" title="All 2 branches missed.">				for (int i = offset; i &lt; end; i++) {</span>
<span class="nc" id="L786">					final int idx = i * vertexSize + posoff;</span>
<span class="nc" id="L787">					tmpV.set(verts.get(idx), 0, 0);</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">					if (transform != null) tmpV.mul(transform);</span>
<span class="nc" id="L789">					out.ext(tmpV);</span>
				}
			}
<span class="nc" id="L792">			break;</span>
		case 2:
<span class="nc bnc" id="L794" title="All 2 branches missed.">			if (numIndices &gt; 0) {</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">				for (int i = offset; i &lt; end; i++) {</span>
<span class="nc" id="L796">					final int idx = index.get(i) * vertexSize + posoff;</span>
<span class="nc" id="L797">					tmpV.set(verts.get(idx), verts.get(idx + 1), 0);</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">					if (transform != null) tmpV.mul(transform);</span>
<span class="nc" id="L799">					out.ext(tmpV);</span>
				}
			} else {
<span class="nc bnc" id="L802" title="All 2 branches missed.">				for (int i = offset; i &lt; end; i++) {</span>
<span class="nc" id="L803">					final int idx = i * vertexSize + posoff;</span>
<span class="nc" id="L804">					tmpV.set(verts.get(idx), verts.get(idx + 1), 0);</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">					if (transform != null) tmpV.mul(transform);</span>
<span class="nc" id="L806">					out.ext(tmpV);</span>
				}
			}
<span class="nc" id="L809">			break;</span>
		case 3:
<span class="nc bnc" id="L811" title="All 2 branches missed.">			if (numIndices &gt; 0) {</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">				for (int i = offset; i &lt; end; i++) {</span>
<span class="nc" id="L813">					final int idx = index.get(i) * vertexSize + posoff;</span>
<span class="nc" id="L814">					tmpV.set(verts.get(idx), verts.get(idx + 1), verts.get(idx + 2));</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">					if (transform != null) tmpV.mul(transform);</span>
<span class="nc" id="L816">					out.ext(tmpV);</span>
				}
			} else {
<span class="nc bnc" id="L819" title="All 2 branches missed.">				for (int i = offset; i &lt; end; i++) {</span>
<span class="nc" id="L820">					final int idx = i * vertexSize + posoff;</span>
<span class="nc" id="L821">					tmpV.set(verts.get(idx), verts.get(idx + 1), verts.get(idx + 2));</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">					if (transform != null) tmpV.mul(transform);</span>
<span class="nc" id="L823">					out.ext(tmpV);</span>
				}
			}
			break;
		}
<span class="nc" id="L828">		return out;</span>
	}

	/** Calculates the squared radius of the bounding sphere around the specified center for the specified part.
	 * @param centerX The X coordinate of the center of the bounding sphere
	 * @param centerY The Y coordinate of the center of the bounding sphere
	 * @param centerZ The Z coordinate of the center of the bounding sphere
	 * @param offset the start index of the part.
	 * @param count the amount of indices the part contains.
	 * @return the squared radius of the bounding sphere. */
	public float calculateRadiusSquared (final float centerX, final float centerY, final float centerZ, int offset, int count,
		final Matrix4 transform) {
<span class="nc" id="L840">		int numIndices = getNumIndices();</span>
<span class="nc bnc" id="L841" title="All 6 branches missed.">		if (offset &lt; 0 || count &lt; 1 || offset + count &gt; numIndices) throw new GdxRuntimeException(&quot;Not enough indices&quot;);</span>

<span class="nc" id="L843">		final FloatBuffer verts = vertices.getBuffer();</span>
<span class="nc" id="L844">		final ShortBuffer index = indices.getBuffer();</span>
<span class="nc" id="L845">		final VertexAttribute posAttrib = getVertexAttribute(Usage.Position);</span>
<span class="nc" id="L846">		final int posoff = posAttrib.offset / 4;</span>
<span class="nc" id="L847">		final int vertexSize = vertices.getAttributes().vertexSize / 4;</span>
<span class="nc" id="L848">		final int end = offset + count;</span>

<span class="nc" id="L850">		float result = 0;</span>

<span class="nc bnc" id="L852" title="All 4 branches missed.">		switch (posAttrib.numComponents) {</span>
		case 1:
<span class="nc bnc" id="L854" title="All 2 branches missed.">			for (int i = offset; i &lt; end; i++) {</span>
<span class="nc" id="L855">				final int idx = index.get(i) * vertexSize + posoff;</span>
<span class="nc" id="L856">				tmpV.set(verts.get(idx), 0, 0);</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">				if (transform != null) tmpV.mul(transform);</span>
<span class="nc" id="L858">				final float r = tmpV.sub(centerX, centerY, centerZ).len2();</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">				if (r &gt; result) result = r;</span>
			}
<span class="nc" id="L861">			break;</span>
		case 2:
<span class="nc bnc" id="L863" title="All 2 branches missed.">			for (int i = offset; i &lt; end; i++) {</span>
<span class="nc" id="L864">				final int idx = index.get(i) * vertexSize + posoff;</span>
<span class="nc" id="L865">				tmpV.set(verts.get(idx), verts.get(idx + 1), 0);</span>
<span class="nc bnc" id="L866" title="All 2 branches missed.">				if (transform != null) tmpV.mul(transform);</span>
<span class="nc" id="L867">				final float r = tmpV.sub(centerX, centerY, centerZ).len2();</span>
<span class="nc bnc" id="L868" title="All 2 branches missed.">				if (r &gt; result) result = r;</span>
			}
<span class="nc" id="L870">			break;</span>
		case 3:
<span class="nc bnc" id="L872" title="All 2 branches missed.">			for (int i = offset; i &lt; end; i++) {</span>
<span class="nc" id="L873">				final int idx = index.get(i) * vertexSize + posoff;</span>
<span class="nc" id="L874">				tmpV.set(verts.get(idx), verts.get(idx + 1), verts.get(idx + 2));</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">				if (transform != null) tmpV.mul(transform);</span>
<span class="nc" id="L876">				final float r = tmpV.sub(centerX, centerY, centerZ).len2();</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">				if (r &gt; result) result = r;</span>
			}
			break;
		}
<span class="nc" id="L881">		return result;</span>
	}

	/** Calculates the radius of the bounding sphere around the specified center for the specified part.
	 * @param centerX The X coordinate of the center of the bounding sphere
	 * @param centerY The Y coordinate of the center of the bounding sphere
	 * @param centerZ The Z coordinate of the center of the bounding sphere
	 * @param offset the start index of the part.
	 * @param count the amount of indices the part contains.
	 * @return the radius of the bounding sphere. */
	public float calculateRadius (final float centerX, final float centerY, final float centerZ, int offset, int count,
		final Matrix4 transform) {
<span class="nc" id="L893">		return (float)Math.sqrt(calculateRadiusSquared(centerX, centerY, centerZ, offset, count, transform));</span>
	}

	/** Calculates the squared radius of the bounding sphere around the specified center for the specified part.
	 * @param center The center of the bounding sphere
	 * @param offset the start index of the part.
	 * @param count the amount of indices the part contains.
	 * @return the squared radius of the bounding sphere. */
	public float calculateRadius (final Vector3 center, int offset, int count, final Matrix4 transform) {
<span class="nc" id="L902">		return calculateRadius(center.x, center.y, center.z, offset, count, transform);</span>
	}

	/** Calculates the squared radius of the bounding sphere around the specified center for the specified part.
	 * @param centerX The X coordinate of the center of the bounding sphere
	 * @param centerY The Y coordinate of the center of the bounding sphere
	 * @param centerZ The Z coordinate of the center of the bounding sphere
	 * @param offset the start index of the part.
	 * @param count the amount of indices the part contains.
	 * @return the squared radius of the bounding sphere. */
	public float calculateRadius (final float centerX, final float centerY, final float centerZ, int offset, int count) {
<span class="nc" id="L913">		return calculateRadius(centerX, centerY, centerZ, offset, count, null);</span>
	}

	/** Calculates the squared radius of the bounding sphere around the specified center for the specified part.
	 * @param center The center of the bounding sphere
	 * @param offset the start index of the part.
	 * @param count the amount of indices the part contains.
	 * @return the squared radius of the bounding sphere. */
	public float calculateRadius (final Vector3 center, int offset, int count) {
<span class="nc" id="L922">		return calculateRadius(center.x, center.y, center.z, offset, count, null);</span>
	}

	/** Calculates the squared radius of the bounding sphere around the specified center for the specified part.
	 * @param centerX The X coordinate of the center of the bounding sphere
	 * @param centerY The Y coordinate of the center of the bounding sphere
	 * @param centerZ The Z coordinate of the center of the bounding sphere
	 * @return the squared radius of the bounding sphere. */
	public float calculateRadius (final float centerX, final float centerY, final float centerZ) {
<span class="nc" id="L931">		return calculateRadius(centerX, centerY, centerZ, 0, getNumIndices(), null);</span>
	}

	/** Calculates the squared radius of the bounding sphere around the specified center for the specified part.
	 * @param center The center of the bounding sphere
	 * @return the squared radius of the bounding sphere. */
	public float calculateRadius (final Vector3 center) {
<span class="nc" id="L938">		return calculateRadius(center.x, center.y, center.z, 0, getNumIndices(), null);</span>
	}

	/** @return the backing shortbuffer holding the indices. Does not have to be a direct buffer on Android! */
	public ShortBuffer getIndicesBuffer () {
<span class="nc" id="L943">		return indices.getBuffer();</span>
	}

	private static void addManagedMesh (Application app, Mesh mesh) {
<span class="nc" id="L947">		Array&lt;Mesh&gt; managedResources = meshes.get(app);</span>
<span class="nc bnc" id="L948" title="All 2 branches missed.">		if (managedResources == null) managedResources = new Array&lt;Mesh&gt;();</span>
<span class="nc" id="L949">		managedResources.add(mesh);</span>
<span class="nc" id="L950">		meshes.put(app, managedResources);</span>
<span class="nc" id="L951">	}</span>

	/** Invalidates all meshes so the next time they are rendered new VBO handles are generated.
	 * @param app */
	public static void invalidateAllMeshes (Application app) {
<span class="nc" id="L956">		Array&lt;Mesh&gt; meshesArray = meshes.get(app);</span>
<span class="nc bnc" id="L957" title="All 2 branches missed.">		if (meshesArray == null) return;</span>
<span class="nc bnc" id="L958" title="All 2 branches missed.">		for (int i = 0; i &lt; meshesArray.size; i++) {</span>
<span class="nc" id="L959">			meshesArray.get(i).vertices.invalidate();</span>
<span class="nc" id="L960">			meshesArray.get(i).indices.invalidate();</span>
		}
<span class="nc" id="L962">	}</span>

	/** Will clear the managed mesh cache. I wouldn't use this if i was you :) */
	public static void clearAllMeshes (Application app) {
<span class="nc" id="L966">		meshes.remove(app);</span>
<span class="nc" id="L967">	}</span>

	public static String getManagedStatus () {
<span class="nc" id="L970">		StringBuilder builder = new StringBuilder();</span>
<span class="nc" id="L971">		int i = 0;</span>
<span class="nc" id="L972">		builder.append(&quot;Managed meshes/app: { &quot;);</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">		for (Application app : meshes.keySet()) {</span>
<span class="nc" id="L974">			builder.append(meshes.get(app).size);</span>
<span class="nc" id="L975">			builder.append(&quot; &quot;);</span>
<span class="nc" id="L976">		}</span>
<span class="nc" id="L977">		builder.append(&quot;}&quot;);</span>
<span class="nc" id="L978">		return builder.toString();</span>
	}

	/** Method to scale the positions in the mesh. Normals will be kept as is. This is a potentially slow operation, use with care.
	 * It will also create a temporary float[] which will be garbage collected.
	 * 
	 * @param scaleX scale on x
	 * @param scaleY scale on y
	 * @param scaleZ scale on z */
	public void scale (float scaleX, float scaleY, float scaleZ) {
<span class="nc" id="L988">		final VertexAttribute posAttr = getVertexAttribute(Usage.Position);</span>
<span class="nc" id="L989">		final int offset = posAttr.offset / 4;</span>
<span class="nc" id="L990">		final int numComponents = posAttr.numComponents;</span>
<span class="nc" id="L991">		final int numVertices = getNumVertices();</span>
<span class="nc" id="L992">		final int vertexSize = getVertexSize() / 4;</span>

<span class="nc" id="L994">		final float[] vertices = new float[numVertices * vertexSize];</span>
<span class="nc" id="L995">		getVertices(vertices);</span>

<span class="nc" id="L997">		int idx = offset;</span>
<span class="nc bnc" id="L998" title="All 4 branches missed.">		switch (numComponents) {</span>
		case 1:
<span class="nc bnc" id="L1000" title="All 2 branches missed.">			for (int i = 0; i &lt; numVertices; i++) {</span>
<span class="nc" id="L1001">				vertices[idx] *= scaleX;</span>
<span class="nc" id="L1002">				idx += vertexSize;</span>
			}
<span class="nc" id="L1004">			break;</span>
		case 2:
<span class="nc bnc" id="L1006" title="All 2 branches missed.">			for (int i = 0; i &lt; numVertices; i++) {</span>
<span class="nc" id="L1007">				vertices[idx] *= scaleX;</span>
<span class="nc" id="L1008">				vertices[idx + 1] *= scaleY;</span>
<span class="nc" id="L1009">				idx += vertexSize;</span>
			}
<span class="nc" id="L1011">			break;</span>
		case 3:
<span class="nc bnc" id="L1013" title="All 2 branches missed.">			for (int i = 0; i &lt; numVertices; i++) {</span>
<span class="nc" id="L1014">				vertices[idx] *= scaleX;</span>
<span class="nc" id="L1015">				vertices[idx + 1] *= scaleY;</span>
<span class="nc" id="L1016">				vertices[idx + 2] *= scaleZ;</span>
<span class="nc" id="L1017">				idx += vertexSize;</span>
			}
			break;
		}

<span class="nc" id="L1022">		setVertices(vertices);</span>
<span class="nc" id="L1023">	}</span>

	/** Method to transform the positions in the mesh. Normals will be kept as is. This is a potentially slow operation, use with
	 * care. It will also create a temporary float[] which will be garbage collected.
	 * 
	 * @param matrix the transformation matrix */
	public void transform (final Matrix4 matrix) {
<span class="nc" id="L1030">		transform(matrix, 0, getNumVertices());</span>
<span class="nc" id="L1031">	}</span>

	// TODO: Protected for now, because transforming a portion works but still copies all vertices
	public void transform (final Matrix4 matrix, final int start, final int count) {
<span class="nc" id="L1035">		final VertexAttribute posAttr = getVertexAttribute(Usage.Position);</span>
<span class="nc" id="L1036">		final int posOffset = posAttr.offset / 4;</span>
<span class="nc" id="L1037">		final int stride = getVertexSize() / 4;</span>
<span class="nc" id="L1038">		final int numComponents = posAttr.numComponents;</span>
<span class="nc" id="L1039">		final int numVertices = getNumVertices();</span>

<span class="nc" id="L1041">		final float[] vertices = new float[count * stride];</span>
<span class="nc" id="L1042">		getVertices(start * stride, count * stride, vertices);</span>
		// getVertices(0, vertices.length, vertices);
<span class="nc" id="L1044">		transform(matrix, vertices, stride, posOffset, numComponents, 0, count);</span>
		// setVertices(vertices, 0, vertices.length);
<span class="nc" id="L1046">		updateVertices(start * stride, vertices);</span>
<span class="nc" id="L1047">	}</span>

	/** Method to transform the positions in the float array. Normals will be kept as is. This is a potentially slow operation, use
	 * with care.
	 * @param matrix the transformation matrix
	 * @param vertices the float array
	 * @param vertexSize the number of floats in each vertex
	 * @param offset the offset within a vertex to the position
	 * @param dimensions the size of the position
	 * @param start the vertex to start with
	 * @param count the amount of vertices to transform */
	public static void transform (final Matrix4 matrix, final float[] vertices, int vertexSize, int offset, int dimensions,
		int start, int count) {
<span class="nc bnc" id="L1060" title="All 6 branches missed.">		if (offset &lt; 0 || dimensions &lt; 1 || (offset + dimensions) &gt; vertexSize) throw new IndexOutOfBoundsException();</span>
<span class="nc bnc" id="L1061" title="All 6 branches missed.">		if (start &lt; 0 || count &lt; 1 || ((start + count) * vertexSize) &gt; vertices.length)</span>
<span class="nc" id="L1062">			throw new IndexOutOfBoundsException(&quot;start = &quot; + start + &quot;, count = &quot; + count + &quot;, vertexSize = &quot; + vertexSize</span>
				+ &quot;, length = &quot; + vertices.length);

<span class="nc" id="L1065">		final Vector3 tmp = new Vector3();</span>

<span class="nc" id="L1067">		int idx = offset + (start * vertexSize);</span>
<span class="nc bnc" id="L1068" title="All 4 branches missed.">		switch (dimensions) {</span>
		case 1:
<span class="nc bnc" id="L1070" title="All 2 branches missed.">			for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L1071">				tmp.set(vertices[idx], 0, 0).mul(matrix);</span>
<span class="nc" id="L1072">				vertices[idx] = tmp.x;</span>
<span class="nc" id="L1073">				idx += vertexSize;</span>
			}
<span class="nc" id="L1075">			break;</span>
		case 2:
<span class="nc bnc" id="L1077" title="All 2 branches missed.">			for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L1078">				tmp.set(vertices[idx], vertices[idx + 1], 0).mul(matrix);</span>
<span class="nc" id="L1079">				vertices[idx] = tmp.x;</span>
<span class="nc" id="L1080">				vertices[idx + 1] = tmp.y;</span>
<span class="nc" id="L1081">				idx += vertexSize;</span>
			}
<span class="nc" id="L1083">			break;</span>
		case 3:
<span class="nc bnc" id="L1085" title="All 2 branches missed.">			for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L1086">				tmp.set(vertices[idx], vertices[idx + 1], vertices[idx + 2]).mul(matrix);</span>
<span class="nc" id="L1087">				vertices[idx] = tmp.x;</span>
<span class="nc" id="L1088">				vertices[idx + 1] = tmp.y;</span>
<span class="nc" id="L1089">				vertices[idx + 2] = tmp.z;</span>
<span class="nc" id="L1090">				idx += vertexSize;</span>
			}
			break;
		}
<span class="nc" id="L1094">	}</span>

	/** Method to transform the texture coordinates in the mesh. This is a potentially slow operation, use with care. It will also
	 * create a temporary float[] which will be garbage collected.
	 * 
	 * @param matrix the transformation matrix */
	public void transformUV (final Matrix3 matrix) {
<span class="nc" id="L1101">		transformUV(matrix, 0, getNumVertices());</span>
<span class="nc" id="L1102">	}</span>

	// TODO: Protected for now, because transforming a portion works but still copies all vertices
	protected void transformUV (final Matrix3 matrix, final int start, final int count) {
<span class="nc" id="L1106">		final VertexAttribute posAttr = getVertexAttribute(Usage.TextureCoordinates);</span>
<span class="nc" id="L1107">		final int offset = posAttr.offset / 4;</span>
<span class="nc" id="L1108">		final int vertexSize = getVertexSize() / 4;</span>
<span class="nc" id="L1109">		final int numVertices = getNumVertices();</span>

<span class="nc" id="L1111">		final float[] vertices = new float[numVertices * vertexSize];</span>
		// TODO: getVertices(vertices, start * vertexSize, count * vertexSize);
<span class="nc" id="L1113">		getVertices(0, vertices.length, vertices);</span>
<span class="nc" id="L1114">		transformUV(matrix, vertices, vertexSize, offset, start, count);</span>
<span class="nc" id="L1115">		setVertices(vertices, 0, vertices.length);</span>
		// TODO: setVertices(start * vertexSize, vertices, 0, vertices.length);
<span class="nc" id="L1117">	}</span>

	/** Method to transform the texture coordinates (UV) in the float array. This is a potentially slow operation, use with care.
	 * @param matrix the transformation matrix
	 * @param vertices the float array
	 * @param vertexSize the number of floats in each vertex
	 * @param offset the offset within a vertex to the texture location
	 * @param start the vertex to start with
	 * @param count the amount of vertices to transform */
	public static void transformUV (final Matrix3 matrix, final float[] vertices, int vertexSize, int offset, int start, int count) {
<span class="nc bnc" id="L1127" title="All 6 branches missed.">		if (start &lt; 0 || count &lt; 1 || ((start + count) * vertexSize) &gt; vertices.length)</span>
<span class="nc" id="L1128">			throw new IndexOutOfBoundsException(&quot;start = &quot; + start + &quot;, count = &quot; + count + &quot;, vertexSize = &quot; + vertexSize</span>
				+ &quot;, length = &quot; + vertices.length);

<span class="nc" id="L1131">		final Vector2 tmp = new Vector2();</span>

<span class="nc" id="L1133">		int idx = offset + (start * vertexSize);</span>
<span class="nc bnc" id="L1134" title="All 2 branches missed.">		for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L1135">			tmp.set(vertices[idx], vertices[idx + 1]).mul(matrix);</span>
<span class="nc" id="L1136">			vertices[idx] = tmp.x;</span>
<span class="nc" id="L1137">			vertices[idx + 1] = tmp.y;</span>
<span class="nc" id="L1138">			idx += vertexSize;</span>
		}
<span class="nc" id="L1140">	}</span>

	/** Copies this mesh optionally removing duplicate vertices and/or reducing the amount of attributes.
	 * @param isStatic whether the new mesh is static or not. Allows for internal optimizations.
	 * @param removeDuplicates whether to remove duplicate vertices if possible. Only the vertices specified by usage are checked.
	 * @param usage which attributes (if available) to copy
	 * @return the copy of this mesh */
	public Mesh copy (boolean isStatic, boolean removeDuplicates, final int[] usage) {
		// TODO move this to a copy constructor?
		// TODO duplicate the buffers without double copying the data if possible.
		// TODO perhaps move this code to JNI if it turns out being too slow.
<span class="nc" id="L1151">		final int vertexSize = getVertexSize() / 4;</span>
<span class="nc" id="L1152">		int numVertices = getNumVertices();</span>
<span class="nc" id="L1153">		float[] vertices = new float[numVertices * vertexSize];</span>
<span class="nc" id="L1154">		getVertices(0, vertices.length, vertices);</span>
<span class="nc" id="L1155">		short[] checks = null;</span>
<span class="nc" id="L1156">		VertexAttribute[] attrs = null;</span>
<span class="nc" id="L1157">		int newVertexSize = 0;</span>
<span class="nc bnc" id="L1158" title="All 2 branches missed.">		if (usage != null) {</span>
<span class="nc" id="L1159">			int size = 0;</span>
<span class="nc" id="L1160">			int as = 0;</span>
<span class="nc bnc" id="L1161" title="All 2 branches missed.">			for (int i = 0; i &lt; usage.length; i++)</span>
<span class="nc bnc" id="L1162" title="All 2 branches missed.">				if (getVertexAttribute(usage[i]) != null) {</span>
<span class="nc" id="L1163">					size += getVertexAttribute(usage[i]).numComponents;</span>
<span class="nc" id="L1164">					as++;</span>
				}
<span class="nc bnc" id="L1166" title="All 2 branches missed.">			if (size &gt; 0) {</span>
<span class="nc" id="L1167">				attrs = new VertexAttribute[as];</span>
<span class="nc" id="L1168">				checks = new short[size];</span>
<span class="nc" id="L1169">				int idx = -1;</span>
<span class="nc" id="L1170">				int ai = -1;</span>
<span class="nc bnc" id="L1171" title="All 2 branches missed.">				for (int i = 0; i &lt; usage.length; i++) {</span>
<span class="nc" id="L1172">					VertexAttribute a = getVertexAttribute(usage[i]);</span>
<span class="nc bnc" id="L1173" title="All 2 branches missed.">					if (a == null) continue;</span>
<span class="nc bnc" id="L1174" title="All 2 branches missed.">					for (int j = 0; j &lt; a.numComponents; j++)</span>
<span class="nc" id="L1175">						checks[++idx] = (short)(a.offset + j);</span>
<span class="nc" id="L1176">					attrs[++ai] = a.copy();</span>
<span class="nc" id="L1177">					newVertexSize += a.numComponents;</span>
				}
			}
		}
<span class="nc bnc" id="L1181" title="All 2 branches missed.">		if (checks == null) {</span>
<span class="nc" id="L1182">			checks = new short[vertexSize];</span>
<span class="nc bnc" id="L1183" title="All 2 branches missed.">			for (short i = 0; i &lt; vertexSize; i++)</span>
<span class="nc" id="L1184">				checks[i] = i;</span>
<span class="nc" id="L1185">			newVertexSize = vertexSize;</span>
		}

<span class="nc" id="L1188">		int numIndices = getNumIndices();</span>
<span class="nc" id="L1189">		short[] indices = null;</span>
<span class="nc bnc" id="L1190" title="All 2 branches missed.">		if (numIndices &gt; 0) {</span>
<span class="nc" id="L1191">			indices = new short[numIndices];</span>
<span class="nc" id="L1192">			getIndices(indices);</span>
<span class="nc bnc" id="L1193" title="All 4 branches missed.">			if (removeDuplicates || newVertexSize != vertexSize) {</span>
<span class="nc" id="L1194">				float[] tmp = new float[vertices.length];</span>
<span class="nc" id="L1195">				int size = 0;</span>
<span class="nc bnc" id="L1196" title="All 2 branches missed.">				for (int i = 0; i &lt; numIndices; i++) {</span>
<span class="nc" id="L1197">					final int idx1 = indices[i] * vertexSize;</span>
<span class="nc" id="L1198">					short newIndex = -1;</span>
<span class="nc bnc" id="L1199" title="All 2 branches missed.">					if (removeDuplicates) {</span>
<span class="nc bnc" id="L1200" title="All 4 branches missed.">						for (short j = 0; j &lt; size &amp;&amp; newIndex &lt; 0; j++) {</span>
<span class="nc" id="L1201">							final int idx2 = j * newVertexSize;</span>
<span class="nc" id="L1202">							boolean found = true;</span>
<span class="nc bnc" id="L1203" title="All 4 branches missed.">							for (int k = 0; k &lt; checks.length &amp;&amp; found; k++) {</span>
<span class="nc bnc" id="L1204" title="All 2 branches missed.">								if (tmp[idx2 + k] != vertices[idx1 + checks[k]]) found = false;</span>
							}
<span class="nc bnc" id="L1206" title="All 2 branches missed.">							if (found) newIndex = j;</span>
						}
					}
<span class="nc bnc" id="L1209" title="All 2 branches missed.">					if (newIndex &gt; 0)</span>
<span class="nc" id="L1210">						indices[i] = newIndex;</span>
					else {
<span class="nc" id="L1212">						final int idx = size * newVertexSize;</span>
<span class="nc bnc" id="L1213" title="All 2 branches missed.">						for (int j = 0; j &lt; checks.length; j++)</span>
<span class="nc" id="L1214">							tmp[idx + j] = vertices[idx1 + checks[j]];</span>
<span class="nc" id="L1215">						indices[i] = (short)size;</span>
<span class="nc" id="L1216">						size++;</span>
					}
				}
<span class="nc" id="L1219">				vertices = tmp;</span>
<span class="nc" id="L1220">				numVertices = size;</span>
			}
		}

		Mesh result;
<span class="nc bnc" id="L1225" title="All 2 branches missed.">		if (attrs == null)</span>
<span class="nc bnc" id="L1226" title="All 2 branches missed.">			result = new Mesh(isStatic, numVertices, indices == null ? 0 : indices.length, getVertexAttributes());</span>
		else
<span class="nc bnc" id="L1228" title="All 2 branches missed.">			result = new Mesh(isStatic, numVertices, indices == null ? 0 : indices.length, attrs);</span>
<span class="nc" id="L1229">		result.setVertices(vertices, 0, numVertices * newVertexSize);</span>
<span class="nc bnc" id="L1230" title="All 2 branches missed.">		if (indices != null) result.setIndices(indices);</span>
<span class="nc" id="L1231">		return result;</span>
	}

	/** Copies this mesh.
	 * @param isStatic whether the new mesh is static or not. Allows for internal optimizations.
	 * @return the copy of this mesh */
	public Mesh copy (boolean isStatic) {
<span class="nc" id="L1238">		return copy(isStatic, false, null);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>