<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ShaderProgram.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">gdx</a> &gt; <a href="index.source.html" class="el_package">com.badlogic.gdx.graphics.glutils</a> &gt; <span class="el_source">ShaderProgram.java</span></div><h1>ShaderProgram.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2011 See AUTHORS file.
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

package com.badlogic.gdx.graphics.glutils;

import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;

import com.badlogic.gdx.Application;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.Mesh;
import com.badlogic.gdx.math.Matrix3;
import com.badlogic.gdx.math.Matrix4;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.BufferUtils;
import com.badlogic.gdx.utils.Disposable;
import com.badlogic.gdx.utils.ObjectIntMap;
import com.badlogic.gdx.utils.ObjectMap;

/** &lt;p&gt;
 * A shader program encapsulates a vertex and fragment shader pair linked to form a shader program.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * After construction a ShaderProgram can be used to draw {@link Mesh}. To make the GPU use a specific ShaderProgram the programs
 * {@link ShaderProgram#begin()} method must be used which effectively binds the program.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * When a ShaderProgram is bound one can set uniforms, vertex attributes and attributes as needed via the respective methods.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * A ShaderProgram can be unbound with a call to {@link ShaderProgram#end()}
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * A ShaderProgram must be disposed via a call to {@link ShaderProgram#dispose()} when it is no longer needed
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * ShaderPrograms are managed. In case the OpenGL context is lost all shaders get invalidated and have to be reloaded. This
 * happens on Android when a user switches to another application or receives an incoming call. Managed ShaderPrograms are
 * automatically reloaded when the OpenGL context is recreated so you don't have to do this manually.
 * &lt;/p&gt;
 * 
 * @author mzechner */
public class ShaderProgram implements Disposable {
	/** default name for position attributes **/
	public static final String POSITION_ATTRIBUTE = &quot;a_position&quot;;
	/** default name for normal attributes **/
	public static final String NORMAL_ATTRIBUTE = &quot;a_normal&quot;;
	/** default name for color attributes **/
	public static final String COLOR_ATTRIBUTE = &quot;a_color&quot;;
	/** default name for texcoords attributes, append texture unit number **/
	public static final String TEXCOORD_ATTRIBUTE = &quot;a_texCoord&quot;;
	/** default name for tangent attribute **/
	public static final String TANGENT_ATTRIBUTE = &quot;a_tangent&quot;;
	/** default name for binormal attribute **/
	public static final String BINORMAL_ATTRIBUTE = &quot;a_binormal&quot;;
	/** default name for boneweight attribute **/
	public static final String BONEWEIGHT_ATTRIBUTE = &quot;a_boneWeight&quot;;

	/** flag indicating whether attributes &amp; uniforms must be present at all times **/
<span class="nc" id="L86">	public static boolean pedantic = true;</span>

	/** code that is always added to the vertex shader code, typically used to inject a #version line. Note that this is added
	 * as-is, you should include a newline (`\n`) if needed. */
<span class="nc" id="L90">	public static String prependVertexCode = &quot;&quot;;</span>

	/** code that is always added to every fragment shader code, typically used to inject a #version line. Note that this is added
	 * as-is, you should include a newline (`\n`) if needed. */
<span class="nc" id="L94">	public static String prependFragmentCode = &quot;&quot;;</span>

	/** the list of currently available shaders **/
<span class="nc" id="L97">	private final static ObjectMap&lt;Application, Array&lt;ShaderProgram&gt;&gt; shaders = new ObjectMap&lt;Application, Array&lt;ShaderProgram&gt;&gt;();</span>

	/** the log **/
<span class="nc" id="L100">	private String log = &quot;&quot;;</span>

	/** whether this program compiled successfully **/
	private boolean isCompiled;

	/** uniform lookup **/
<span class="nc" id="L106">	private final ObjectIntMap&lt;String&gt; uniforms = new ObjectIntMap&lt;String&gt;();</span>

	/** uniform types **/
<span class="nc" id="L109">	private final ObjectIntMap&lt;String&gt; uniformTypes = new ObjectIntMap&lt;String&gt;();</span>

	/** uniform sizes **/
<span class="nc" id="L112">	private final ObjectIntMap&lt;String&gt; uniformSizes = new ObjectIntMap&lt;String&gt;();</span>

	/** uniform names **/
	private String[] uniformNames;

	/** attribute lookup **/
<span class="nc" id="L118">	private final ObjectIntMap&lt;String&gt; attributes = new ObjectIntMap&lt;String&gt;();</span>

	/** attribute types **/
<span class="nc" id="L121">	private final ObjectIntMap&lt;String&gt; attributeTypes = new ObjectIntMap&lt;String&gt;();</span>

	/** attribute sizes **/
<span class="nc" id="L124">	private final ObjectIntMap&lt;String&gt; attributeSizes = new ObjectIntMap&lt;String&gt;();</span>

	/** attribute names **/
	private String[] attributeNames;

	/** program handle **/
	private int program;

	/** vertex shader handle **/
	private int vertexShaderHandle;

	/** fragment shader handle **/
	private int fragmentShaderHandle;

	/** matrix float buffer **/
	private final FloatBuffer matrix;

	/** vertex shader source **/
	private final String vertexShaderSource;

	/** fragment shader source **/
	private final String fragmentShaderSource;

	/** whether this shader was invalidated **/
	private boolean invalidated;

	/** reference count **/
<span class="nc" id="L151">	private int refCount = 0;</span>

	/** Constructs a new ShaderProgram and immediately compiles it.
	 * 
	 * @param vertexShader the vertex shader
	 * @param fragmentShader the fragment shader */

<span class="nc" id="L158">	public ShaderProgram (String vertexShader, String fragmentShader) {</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">		if (vertexShader == null) throw new IllegalArgumentException(&quot;vertex shader must not be null&quot;);</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">		if (fragmentShader == null) throw new IllegalArgumentException(&quot;fragment shader must not be null&quot;);</span>

<span class="nc bnc" id="L162" title="All 4 branches missed.">		if (prependVertexCode != null &amp;&amp; prependVertexCode.length() &gt; 0)</span>
<span class="nc" id="L163">			vertexShader = prependVertexCode + vertexShader;</span>
<span class="nc bnc" id="L164" title="All 4 branches missed.">		if (prependFragmentCode != null &amp;&amp; prependFragmentCode.length() &gt; 0)</span>
<span class="nc" id="L165">			fragmentShader = prependFragmentCode + fragmentShader;</span>

<span class="nc" id="L167">		this.vertexShaderSource = vertexShader;</span>
<span class="nc" id="L168">		this.fragmentShaderSource = fragmentShader;</span>
<span class="nc" id="L169">		this.matrix = BufferUtils.newFloatBuffer(16);</span>

<span class="nc" id="L171">		compileShaders(vertexShader, fragmentShader);</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">		if (isCompiled()) {</span>
<span class="nc" id="L173">			fetchAttributes();</span>
<span class="nc" id="L174">			fetchUniforms();</span>
<span class="nc" id="L175">			addManagedShader(Gdx.app, this);</span>
		}
<span class="nc" id="L177">	}</span>

	public ShaderProgram (FileHandle vertexShader, FileHandle fragmentShader) {
<span class="nc" id="L180">		this(vertexShader.readString(), fragmentShader.readString());</span>
<span class="nc" id="L181">	}</span>

	/** Loads and compiles the shaders, creates a new program and links the shaders.
	 * 
	 * @param vertexShader
	 * @param fragmentShader */
	private void compileShaders (String vertexShader, String fragmentShader) {
<span class="nc" id="L188">		vertexShaderHandle = loadShader(GL20.GL_VERTEX_SHADER, vertexShader);</span>
<span class="nc" id="L189">		fragmentShaderHandle = loadShader(GL20.GL_FRAGMENT_SHADER, fragmentShader);</span>

<span class="nc bnc" id="L191" title="All 4 branches missed.">		if (vertexShaderHandle == -1 || fragmentShaderHandle == -1) {</span>
<span class="nc" id="L192">			isCompiled = false;</span>
<span class="nc" id="L193">			return;</span>
		}

<span class="nc" id="L196">		program = linkProgram(createProgram());</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">		if (program == -1) {</span>
<span class="nc" id="L198">			isCompiled = false;</span>
<span class="nc" id="L199">			return;</span>
		}

<span class="nc" id="L202">		isCompiled = true;</span>
<span class="nc" id="L203">	}</span>

	private int loadShader (int type, String source) {
<span class="nc" id="L206">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L207">		IntBuffer intbuf = BufferUtils.newIntBuffer(1);</span>

<span class="nc" id="L209">		int shader = gl.glCreateShader(type);</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">		if (shader == 0) return -1;</span>

<span class="nc" id="L212">		gl.glShaderSource(shader, source);</span>
<span class="nc" id="L213">		gl.glCompileShader(shader);</span>
<span class="nc" id="L214">		gl.glGetShaderiv(shader, GL20.GL_COMPILE_STATUS, intbuf);</span>

<span class="nc" id="L216">		int compiled = intbuf.get(0);</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">		if (compiled == 0) {</span>
// gl.glGetShaderiv(shader, GL20.GL_INFO_LOG_LENGTH, intbuf);
// int infoLogLength = intbuf.get(0);
// if (infoLogLength &gt; 1) {
<span class="nc" id="L221">			String infoLog = gl.glGetShaderInfoLog(shader);</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">			log += type == GL20.GL_VERTEX_SHADER ? &quot;Vertex shader\n&quot; : &quot;Fragment shader:\n&quot;;</span>
<span class="nc" id="L223">			log += infoLog;</span>
// }
<span class="nc" id="L225">			return -1;</span>
		}

<span class="nc" id="L228">		return shader;</span>
	}

	protected int createProgram () {
<span class="nc" id="L232">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L233">		int program = gl.glCreateProgram();</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">		return program != 0 ? program : -1;</span>
	}

	private int linkProgram (int program) {
<span class="nc" id="L238">		GL20 gl = Gdx.gl20;</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">		if (program == -1) return -1;</span>

<span class="nc" id="L241">		gl.glAttachShader(program, vertexShaderHandle);</span>
<span class="nc" id="L242">		gl.glAttachShader(program, fragmentShaderHandle);</span>
<span class="nc" id="L243">		gl.glLinkProgram(program);</span>

<span class="nc" id="L245">		ByteBuffer tmp = ByteBuffer.allocateDirect(4);</span>
<span class="nc" id="L246">		tmp.order(ByteOrder.nativeOrder());</span>
<span class="nc" id="L247">		IntBuffer intbuf = tmp.asIntBuffer();</span>

<span class="nc" id="L249">		gl.glGetProgramiv(program, GL20.GL_LINK_STATUS, intbuf);</span>
<span class="nc" id="L250">		int linked = intbuf.get(0);</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">		if (linked == 0) {</span>
// Gdx.gl20.glGetProgramiv(program, GL20.GL_INFO_LOG_LENGTH, intbuf);
// int infoLogLength = intbuf.get(0);
// if (infoLogLength &gt; 1) {
<span class="nc" id="L255">			log = Gdx.gl20.glGetProgramInfoLog(program);</span>
// }
<span class="nc" id="L257">			return -1;</span>
		}

<span class="nc" id="L260">		return program;</span>
	}

<span class="nc" id="L263">	final static IntBuffer intbuf = BufferUtils.newIntBuffer(1);</span>

	/** @return the log info for the shader compilation and program linking stage. The shader needs to be bound for this method to
	 *         have an effect. */
	public String getLog () {
<span class="nc bnc" id="L268" title="All 2 branches missed.">		if (isCompiled) {</span>
// Gdx.gl20.glGetProgramiv(program, GL20.GL_INFO_LOG_LENGTH, intbuf);
// int infoLogLength = intbuf.get(0);
// if (infoLogLength &gt; 1) {
<span class="nc" id="L272">			log = Gdx.gl20.glGetProgramInfoLog(program);</span>
// }
<span class="nc" id="L274">			return log;</span>
		} else {
<span class="nc" id="L276">			return log;</span>
		}
	}

	/** @return whether this ShaderProgram compiled successfully. */
	public boolean isCompiled () {
<span class="nc" id="L282">		return isCompiled;</span>
	}

	private int fetchAttributeLocation (String name) {
<span class="nc" id="L286">		GL20 gl = Gdx.gl20;</span>
		// -2 == not yet cached
		// -1 == cached but not found
		int location;
<span class="nc bnc" id="L290" title="All 2 branches missed.">		if ((location = attributes.get(name, -2)) == -2) {</span>
<span class="nc" id="L291">			location = gl.glGetAttribLocation(program, name);</span>
<span class="nc" id="L292">			attributes.put(name, location);</span>
		}
<span class="nc" id="L294">		return location;</span>
	}

	private int fetchUniformLocation (String name) {
<span class="nc" id="L298">		return fetchUniformLocation(name, pedantic);</span>
	}

	public int fetchUniformLocation (String name, boolean pedantic) {
<span class="nc" id="L302">		GL20 gl = Gdx.gl20;</span>
		// -2 == not yet cached
		// -1 == cached but not found
		int location;
<span class="nc bnc" id="L306" title="All 2 branches missed.">		if ((location = uniforms.get(name, -2)) == -2) {</span>
<span class="nc" id="L307">			location = gl.glGetUniformLocation(program, name);</span>
<span class="nc bnc" id="L308" title="All 4 branches missed.">			if (location == -1 &amp;&amp; pedantic) {</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">				if (isCompiled) throw new IllegalArgumentException(&quot;no uniform with name '&quot; + name + &quot;' in shader&quot;);</span>
<span class="nc" id="L310">				throw new IllegalStateException(&quot;An attempted fetch uniform from uncompiled shader \n&quot; + getLog());</span>
			}
<span class="nc" id="L312">			uniforms.put(name, location);</span>
		}
<span class="nc" id="L314">		return location;</span>
	}

	/** Sets the uniform with the given name. The {@link ShaderProgram} must be bound for this to work.
	 * 
	 * @param name the name of the uniform
	 * @param value the value */
	public void setUniformi (String name, int value) {
<span class="nc" id="L322">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L323">		checkManaged();</span>
<span class="nc" id="L324">		int location = fetchUniformLocation(name);</span>
<span class="nc" id="L325">		gl.glUniform1i(location, value);</span>
<span class="nc" id="L326">	}</span>

	public void setUniformi (int location, int value) {
<span class="nc" id="L329">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L330">		checkManaged();</span>
<span class="nc" id="L331">		gl.glUniform1i(location, value);</span>
<span class="nc" id="L332">	}</span>

	/** Sets the uniform with the given name. The {@link ShaderProgram} must be bound for this to work.
	 * 
	 * @param name the name of the uniform
	 * @param value1 the first value
	 * @param value2 the second value */
	public void setUniformi (String name, int value1, int value2) {
<span class="nc" id="L340">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L341">		checkManaged();</span>
<span class="nc" id="L342">		int location = fetchUniformLocation(name);</span>
<span class="nc" id="L343">		gl.glUniform2i(location, value1, value2);</span>
<span class="nc" id="L344">	}</span>

	public void setUniformi (int location, int value1, int value2) {
<span class="nc" id="L347">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L348">		checkManaged();</span>
<span class="nc" id="L349">		gl.glUniform2i(location, value1, value2);</span>
<span class="nc" id="L350">	}</span>

	/** Sets the uniform with the given name. The {@link ShaderProgram} must be bound for this to work.
	 * 
	 * @param name the name of the uniform
	 * @param value1 the first value
	 * @param value2 the second value
	 * @param value3 the third value */
	public void setUniformi (String name, int value1, int value2, int value3) {
<span class="nc" id="L359">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L360">		checkManaged();</span>
<span class="nc" id="L361">		int location = fetchUniformLocation(name);</span>
<span class="nc" id="L362">		gl.glUniform3i(location, value1, value2, value3);</span>
<span class="nc" id="L363">	}</span>

	public void setUniformi (int location, int value1, int value2, int value3) {
<span class="nc" id="L366">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L367">		checkManaged();</span>
<span class="nc" id="L368">		gl.glUniform3i(location, value1, value2, value3);</span>
<span class="nc" id="L369">	}</span>

	/** Sets the uniform with the given name. The {@link ShaderProgram} must be bound for this to work.
	 * 
	 * @param name the name of the uniform
	 * @param value1 the first value
	 * @param value2 the second value
	 * @param value3 the third value
	 * @param value4 the fourth value */
	public void setUniformi (String name, int value1, int value2, int value3, int value4) {
<span class="nc" id="L379">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L380">		checkManaged();</span>
<span class="nc" id="L381">		int location = fetchUniformLocation(name);</span>
<span class="nc" id="L382">		gl.glUniform4i(location, value1, value2, value3, value4);</span>
<span class="nc" id="L383">	}</span>

	public void setUniformi (int location, int value1, int value2, int value3, int value4) {
<span class="nc" id="L386">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L387">		checkManaged();</span>
<span class="nc" id="L388">		gl.glUniform4i(location, value1, value2, value3, value4);</span>
<span class="nc" id="L389">	}</span>

	/** Sets the uniform with the given name. The {@link ShaderProgram} must be bound for this to work.
	 * 
	 * @param name the name of the uniform
	 * @param value the value */
	public void setUniformf (String name, float value) {
<span class="nc" id="L396">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L397">		checkManaged();</span>
<span class="nc" id="L398">		int location = fetchUniformLocation(name);</span>
<span class="nc" id="L399">		gl.glUniform1f(location, value);</span>
<span class="nc" id="L400">	}</span>

	public void setUniformf (int location, float value) {
<span class="nc" id="L403">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L404">		checkManaged();</span>
<span class="nc" id="L405">		gl.glUniform1f(location, value);</span>
<span class="nc" id="L406">	}</span>

	/** Sets the uniform with the given name. The {@link ShaderProgram} must be bound for this to work.
	 * 
	 * @param name the name of the uniform
	 * @param value1 the first value
	 * @param value2 the second value */
	public void setUniformf (String name, float value1, float value2) {
<span class="nc" id="L414">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L415">		checkManaged();</span>
<span class="nc" id="L416">		int location = fetchUniformLocation(name);</span>
<span class="nc" id="L417">		gl.glUniform2f(location, value1, value2);</span>
<span class="nc" id="L418">	}</span>

	public void setUniformf (int location, float value1, float value2) {
<span class="nc" id="L421">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L422">		checkManaged();</span>
<span class="nc" id="L423">		gl.glUniform2f(location, value1, value2);</span>
<span class="nc" id="L424">	}</span>

	/** Sets the uniform with the given name. The {@link ShaderProgram} must be bound for this to work.
	 * 
	 * @param name the name of the uniform
	 * @param value1 the first value
	 * @param value2 the second value
	 * @param value3 the third value */
	public void setUniformf (String name, float value1, float value2, float value3) {
<span class="nc" id="L433">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L434">		checkManaged();</span>
<span class="nc" id="L435">		int location = fetchUniformLocation(name);</span>
<span class="nc" id="L436">		gl.glUniform3f(location, value1, value2, value3);</span>
<span class="nc" id="L437">	}</span>

	public void setUniformf (int location, float value1, float value2, float value3) {
<span class="nc" id="L440">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L441">		checkManaged();</span>
<span class="nc" id="L442">		gl.glUniform3f(location, value1, value2, value3);</span>
<span class="nc" id="L443">	}</span>

	/** Sets the uniform with the given name. The {@link ShaderProgram} must be bound for this to work.
	 * 
	 * @param name the name of the uniform
	 * @param value1 the first value
	 * @param value2 the second value
	 * @param value3 the third value
	 * @param value4 the fourth value */
	public void setUniformf (String name, float value1, float value2, float value3, float value4) {
<span class="nc" id="L453">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L454">		checkManaged();</span>
<span class="nc" id="L455">		int location = fetchUniformLocation(name);</span>
<span class="nc" id="L456">		gl.glUniform4f(location, value1, value2, value3, value4);</span>
<span class="nc" id="L457">	}</span>

	public void setUniformf (int location, float value1, float value2, float value3, float value4) {
<span class="nc" id="L460">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L461">		checkManaged();</span>
<span class="nc" id="L462">		gl.glUniform4f(location, value1, value2, value3, value4);</span>
<span class="nc" id="L463">	}</span>

	public void setUniform1fv (String name, float[] values, int offset, int length) {
<span class="nc" id="L466">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L467">		checkManaged();</span>
<span class="nc" id="L468">		int location = fetchUniformLocation(name);</span>
<span class="nc" id="L469">		gl.glUniform1fv(location, length, values, offset);</span>
<span class="nc" id="L470">	}</span>

	public void setUniform1fv (int location, float[] values, int offset, int length) {
<span class="nc" id="L473">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L474">		checkManaged();</span>
<span class="nc" id="L475">		gl.glUniform1fv(location, length, values, offset);</span>
<span class="nc" id="L476">	}</span>

	public void setUniform2fv (String name, float[] values, int offset, int length) {
<span class="nc" id="L479">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L480">		checkManaged();</span>
<span class="nc" id="L481">		int location = fetchUniformLocation(name);</span>
<span class="nc" id="L482">		gl.glUniform2fv(location, length / 2, values, offset);</span>
<span class="nc" id="L483">	}</span>

	public void setUniform2fv (int location, float[] values, int offset, int length) {
<span class="nc" id="L486">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L487">		checkManaged();</span>
<span class="nc" id="L488">		gl.glUniform2fv(location, length / 2, values, offset);</span>
<span class="nc" id="L489">	}</span>

	public void setUniform3fv (String name, float[] values, int offset, int length) {
<span class="nc" id="L492">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L493">		checkManaged();</span>
<span class="nc" id="L494">		int location = fetchUniformLocation(name);</span>
<span class="nc" id="L495">		gl.glUniform3fv(location, length / 3, values, offset);</span>
<span class="nc" id="L496">	}</span>

	public void setUniform3fv (int location, float[] values, int offset, int length) {
<span class="nc" id="L499">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L500">		checkManaged();</span>
<span class="nc" id="L501">		gl.glUniform3fv(location, length / 3, values, offset);</span>
<span class="nc" id="L502">	}</span>

	public void setUniform4fv (String name, float[] values, int offset, int length) {
<span class="nc" id="L505">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L506">		checkManaged();</span>
<span class="nc" id="L507">		int location = fetchUniformLocation(name);</span>
<span class="nc" id="L508">		gl.glUniform4fv(location, length / 4, values, offset);</span>
<span class="nc" id="L509">	}</span>

	public void setUniform4fv (int location, float[] values, int offset, int length) {
<span class="nc" id="L512">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L513">		checkManaged();</span>
<span class="nc" id="L514">		gl.glUniform4fv(location, length / 4, values, offset);</span>
<span class="nc" id="L515">	}</span>

	/** Sets the uniform matrix with the given name. The {@link ShaderProgram} must be bound for this to work.
	 * 
	 * @param name the name of the uniform
	 * @param matrix the matrix */
	public void setUniformMatrix (String name, Matrix4 matrix) {
<span class="nc" id="L522">		setUniformMatrix(name, matrix, false);</span>
<span class="nc" id="L523">	}</span>

	/** Sets the uniform matrix with the given name. The {@link ShaderProgram} must be bound for this to work.
	 * 
	 * @param name the name of the uniform
	 * @param matrix the matrix
	 * @param transpose whether the matrix should be transposed */
	public void setUniformMatrix (String name, Matrix4 matrix, boolean transpose) {
<span class="nc" id="L531">		setUniformMatrix(fetchUniformLocation(name), matrix, transpose);</span>
<span class="nc" id="L532">	}</span>

	public void setUniformMatrix (int location, Matrix4 matrix) {
<span class="nc" id="L535">		setUniformMatrix(location, matrix, false);</span>
<span class="nc" id="L536">	}</span>

	public void setUniformMatrix (int location, Matrix4 matrix, boolean transpose) {
<span class="nc" id="L539">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L540">		checkManaged();</span>
<span class="nc" id="L541">		gl.glUniformMatrix4fv(location, 1, transpose, matrix.val, 0);</span>
<span class="nc" id="L542">	}</span>

	/** Sets the uniform matrix with the given name. The {@link ShaderProgram} must be bound for this to work.
	 * 
	 * @param name the name of the uniform
	 * @param matrix the matrix */
	public void setUniformMatrix (String name, Matrix3 matrix) {
<span class="nc" id="L549">		setUniformMatrix(name, matrix, false);</span>
<span class="nc" id="L550">	}</span>

	/** Sets the uniform matrix with the given name. The {@link ShaderProgram} must be bound for this to work.
	 * 
	 * @param name the name of the uniform
	 * @param matrix the matrix
	 * @param transpose whether the uniform matrix should be transposed */
	public void setUniformMatrix (String name, Matrix3 matrix, boolean transpose) {
<span class="nc" id="L558">		setUniformMatrix(fetchUniformLocation(name), matrix, transpose);</span>
<span class="nc" id="L559">	}</span>

	public void setUniformMatrix (int location, Matrix3 matrix) {
<span class="nc" id="L562">		setUniformMatrix(location, matrix, false);</span>
<span class="nc" id="L563">	}</span>

	public void setUniformMatrix (int location, Matrix3 matrix, boolean transpose) {
<span class="nc" id="L566">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L567">		checkManaged();</span>
<span class="nc" id="L568">		gl.glUniformMatrix3fv(location, 1, transpose, matrix.val, 0);</span>
<span class="nc" id="L569">	}</span>

	/** Sets an array of uniform matrices with the given name. The {@link ShaderProgram} must be bound for this to work.
	 * 
	 * @param name the name of the uniform
	 * @param buffer buffer containing the matrix data
	 * @param transpose whether the uniform matrix should be transposed */
	public void setUniformMatrix3fv (String name, FloatBuffer buffer, int count, boolean transpose) {
<span class="nc" id="L577">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L578">		checkManaged();</span>
<span class="nc" id="L579">		buffer.position(0);</span>
<span class="nc" id="L580">		int location = fetchUniformLocation(name);</span>
<span class="nc" id="L581">		gl.glUniformMatrix3fv(location, count, transpose, buffer);</span>
<span class="nc" id="L582">	}</span>

	/** Sets an array of uniform matrices with the given name. The {@link ShaderProgram} must be bound for this to work.
	 * 
	 * @param name the name of the uniform
	 * @param buffer buffer containing the matrix data
	 * @param transpose whether the uniform matrix should be transposed */
	public void setUniformMatrix4fv (String name, FloatBuffer buffer, int count, boolean transpose) {
<span class="nc" id="L590">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L591">		checkManaged();</span>
<span class="nc" id="L592">		buffer.position(0);</span>
<span class="nc" id="L593">		int location = fetchUniformLocation(name);</span>
<span class="nc" id="L594">		gl.glUniformMatrix4fv(location, count, transpose, buffer);</span>
<span class="nc" id="L595">	}</span>

	public void setUniformMatrix4fv (int location, float[] values, int offset, int length) {
<span class="nc" id="L598">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L599">		checkManaged();</span>
<span class="nc" id="L600">		gl.glUniformMatrix4fv(location, length / 16, false, values, offset);</span>
<span class="nc" id="L601">	}</span>

	public void setUniformMatrix4fv (String name, float[] values, int offset, int length) {
<span class="nc" id="L604">		setUniformMatrix4fv(fetchUniformLocation(name), values, offset, length);</span>
<span class="nc" id="L605">	}</span>

	/** Sets the uniform with the given name. The {@link ShaderProgram} must be bound for this to work.
	 * 
	 * @param name the name of the uniform
	 * @param values x and y as the first and second values respectively */
	public void setUniformf (String name, Vector2 values) {
<span class="nc" id="L612">		setUniformf(name, values.x, values.y);</span>
<span class="nc" id="L613">	}</span>

	public void setUniformf (int location, Vector2 values) {
<span class="nc" id="L616">		setUniformf(location, values.x, values.y);</span>
<span class="nc" id="L617">	}</span>

	/** Sets the uniform with the given name. The {@link ShaderProgram} must be bound for this to work.
	 * 
	 * @param name the name of the uniform
	 * @param values x, y and z as the first, second and third values respectively */
	public void setUniformf (String name, Vector3 values) {
<span class="nc" id="L624">		setUniformf(name, values.x, values.y, values.z);</span>
<span class="nc" id="L625">	}</span>

	public void setUniformf (int location, Vector3 values) {
<span class="nc" id="L628">		setUniformf(location, values.x, values.y, values.z);</span>
<span class="nc" id="L629">	}</span>

	/** Sets the uniform with the given name. The {@link ShaderProgram} must be bound for this to work.
	 * 
	 * @param name the name of the uniform
	 * @param values r, g, b and a as the first through fourth values respectively */
	public void setUniformf (String name, Color values) {
<span class="nc" id="L636">		setUniformf(name, values.r, values.g, values.b, values.a);</span>
<span class="nc" id="L637">	}</span>

	public void setUniformf (int location, Color values) {
<span class="nc" id="L640">		setUniformf(location, values.r, values.g, values.b, values.a);</span>
<span class="nc" id="L641">	}</span>

	/** Sets the vertex attribute with the given name. The {@link ShaderProgram} must be bound for this to work.
	 * 
	 * @param name the attribute name
	 * @param size the number of components, must be &gt;= 1 and &lt;= 4
	 * @param type the type, must be one of GL20.GL_BYTE, GL20.GL_UNSIGNED_BYTE, GL20.GL_SHORT,
	 *           GL20.GL_UNSIGNED_SHORT,GL20.GL_FIXED, or GL20.GL_FLOAT. GL_FIXED will not work on the desktop
	 * @param normalize whether fixed point data should be normalized. Will not work on the desktop
	 * @param stride the stride in bytes between successive attributes
	 * @param buffer the buffer containing the vertex attributes. */
	public void setVertexAttribute (String name, int size, int type, boolean normalize, int stride, Buffer buffer) {
<span class="nc" id="L653">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L654">		checkManaged();</span>
<span class="nc" id="L655">		int location = fetchAttributeLocation(name);</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">		if (location == -1) return;</span>
<span class="nc" id="L657">		gl.glVertexAttribPointer(location, size, type, normalize, stride, buffer);</span>
<span class="nc" id="L658">	}</span>

	public void setVertexAttribute (int location, int size, int type, boolean normalize, int stride, Buffer buffer) {
<span class="nc" id="L661">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L662">		checkManaged();</span>
<span class="nc" id="L663">		gl.glVertexAttribPointer(location, size, type, normalize, stride, buffer);</span>
<span class="nc" id="L664">	}</span>

	/** Sets the vertex attribute with the given name. The {@link ShaderProgram} must be bound for this to work.
	 * 
	 * @param name the attribute name
	 * @param size the number of components, must be &gt;= 1 and &lt;= 4
	 * @param type the type, must be one of GL20.GL_BYTE, GL20.GL_UNSIGNED_BYTE, GL20.GL_SHORT,
	 *           GL20.GL_UNSIGNED_SHORT,GL20.GL_FIXED, or GL20.GL_FLOAT. GL_FIXED will not work on the desktop
	 * @param normalize whether fixed point data should be normalized. Will not work on the desktop
	 * @param stride the stride in bytes between successive attributes
	 * @param offset byte offset into the vertex buffer object bound to GL20.GL_ARRAY_BUFFER. */
	public void setVertexAttribute (String name, int size, int type, boolean normalize, int stride, int offset) {
<span class="nc" id="L676">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L677">		checkManaged();</span>
<span class="nc" id="L678">		int location = fetchAttributeLocation(name);</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">		if (location == -1) return;</span>
<span class="nc" id="L680">		gl.glVertexAttribPointer(location, size, type, normalize, stride, offset);</span>
<span class="nc" id="L681">	}</span>

	public void setVertexAttribute (int location, int size, int type, boolean normalize, int stride, int offset) {
<span class="nc" id="L684">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L685">		checkManaged();</span>
<span class="nc" id="L686">		gl.glVertexAttribPointer(location, size, type, normalize, stride, offset);</span>
<span class="nc" id="L687">	}</span>

	/** Makes OpenGL ES 2.0 use this vertex and fragment shader pair. When you are done with this shader you have to call
	 * {@link ShaderProgram#end()}. */
	public void begin () {
<span class="nc" id="L692">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L693">		checkManaged();</span>
<span class="nc" id="L694">		gl.glUseProgram(program);</span>
<span class="nc" id="L695">	}</span>

	/** Disables this shader. Must be called when one is done with the shader. Don't mix it with dispose, that will release the
	 * shader resources. */
	public void end () {
<span class="nc" id="L700">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L701">		gl.glUseProgram(0);</span>
<span class="nc" id="L702">	}</span>

	/** Disposes all resources associated with this shader. Must be called when the shader is no longer used. */
	public void dispose () {
<span class="nc" id="L706">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L707">		gl.glUseProgram(0);</span>
<span class="nc" id="L708">		gl.glDeleteShader(vertexShaderHandle);</span>
<span class="nc" id="L709">		gl.glDeleteShader(fragmentShaderHandle);</span>
<span class="nc" id="L710">		gl.glDeleteProgram(program);</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">		if (shaders.get(Gdx.app) != null) shaders.get(Gdx.app).removeValue(this, true);</span>
<span class="nc" id="L712">	}</span>

	/** Disables the vertex attribute with the given name
	 * 
	 * @param name the vertex attribute name */
	public void disableVertexAttribute (String name) {
<span class="nc" id="L718">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L719">		checkManaged();</span>
<span class="nc" id="L720">		int location = fetchAttributeLocation(name);</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">		if (location == -1) return;</span>
<span class="nc" id="L722">		gl.glDisableVertexAttribArray(location);</span>
<span class="nc" id="L723">	}</span>

	public void disableVertexAttribute (int location) {
<span class="nc" id="L726">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L727">		checkManaged();</span>
<span class="nc" id="L728">		gl.glDisableVertexAttribArray(location);</span>
<span class="nc" id="L729">	}</span>

	/** Enables the vertex attribute with the given name
	 * 
	 * @param name the vertex attribute name */
	public void enableVertexAttribute (String name) {
<span class="nc" id="L735">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L736">		checkManaged();</span>
<span class="nc" id="L737">		int location = fetchAttributeLocation(name);</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">		if (location == -1) return;</span>
<span class="nc" id="L739">		gl.glEnableVertexAttribArray(location);</span>
<span class="nc" id="L740">	}</span>

	public void enableVertexAttribute (int location) {
<span class="nc" id="L743">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L744">		checkManaged();</span>
<span class="nc" id="L745">		gl.glEnableVertexAttribArray(location);</span>
<span class="nc" id="L746">	}</span>

	private void checkManaged () {
<span class="nc bnc" id="L749" title="All 2 branches missed.">		if (invalidated) {</span>
<span class="nc" id="L750">			compileShaders(vertexShaderSource, fragmentShaderSource);</span>
<span class="nc" id="L751">			invalidated = false;</span>
		}
<span class="nc" id="L753">	}</span>

	private void addManagedShader (Application app, ShaderProgram shaderProgram) {
<span class="nc" id="L756">		Array&lt;ShaderProgram&gt; managedResources = shaders.get(app);</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">		if (managedResources == null) managedResources = new Array&lt;ShaderProgram&gt;();</span>
<span class="nc" id="L758">		managedResources.add(shaderProgram);</span>
<span class="nc" id="L759">		shaders.put(app, managedResources);</span>
<span class="nc" id="L760">	}</span>

	/** Invalidates all shaders so the next time they are used new handles are generated
	 * @param app */
	public static void invalidateAllShaderPrograms (Application app) {
<span class="nc bnc" id="L765" title="All 2 branches missed.">		if (Gdx.gl20 == null) return;</span>

<span class="nc" id="L767">		Array&lt;ShaderProgram&gt; shaderArray = shaders.get(app);</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">		if (shaderArray == null) return;</span>

<span class="nc bnc" id="L770" title="All 2 branches missed.">		for (int i = 0; i &lt; shaderArray.size; i++) {</span>
<span class="nc" id="L771">			shaderArray.get(i).invalidated = true;</span>
<span class="nc" id="L772">			shaderArray.get(i).checkManaged();</span>
		}
<span class="nc" id="L774">	}</span>

	public static void clearAllShaderPrograms (Application app) {
<span class="nc" id="L777">		shaders.remove(app);</span>
<span class="nc" id="L778">	}</span>

	public static String getManagedStatus () {
<span class="nc" id="L781">		StringBuilder builder = new StringBuilder();</span>
<span class="nc" id="L782">		int i = 0;</span>
<span class="nc" id="L783">		builder.append(&quot;Managed shaders/app: { &quot;);</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">		for (Application app : shaders.keys()) {</span>
<span class="nc" id="L785">			builder.append(shaders.get(app).size);</span>
<span class="nc" id="L786">			builder.append(&quot; &quot;);</span>
<span class="nc" id="L787">		}</span>
<span class="nc" id="L788">		builder.append(&quot;}&quot;);</span>
<span class="nc" id="L789">		return builder.toString();</span>
	}

	/** @return the number of managed shader programs currently loaded */
	public static int getNumManagedShaderPrograms () {
<span class="nc" id="L794">		return shaders.get(Gdx.app).size;</span>
	}

	/** Sets the given attribute
	 * 
	 * @param name the name of the attribute
	 * @param value1 the first value
	 * @param value2 the second value
	 * @param value3 the third value
	 * @param value4 the fourth value */
	public void setAttributef (String name, float value1, float value2, float value3, float value4) {
<span class="nc" id="L805">		GL20 gl = Gdx.gl20;</span>
<span class="nc" id="L806">		int location = fetchAttributeLocation(name);</span>
<span class="nc" id="L807">		gl.glVertexAttrib4f(location, value1, value2, value3, value4);</span>
<span class="nc" id="L808">	}</span>

<span class="nc" id="L810">	IntBuffer params = BufferUtils.newIntBuffer(1);</span>
<span class="nc" id="L811">	IntBuffer type = BufferUtils.newIntBuffer(1);</span>

	private void fetchUniforms () {
<span class="nc" id="L814">		params.clear();</span>
<span class="nc" id="L815">		Gdx.gl20.glGetProgramiv(program, GL20.GL_ACTIVE_UNIFORMS, params);</span>
<span class="nc" id="L816">		int numUniforms = params.get(0);</span>

<span class="nc" id="L818">		uniformNames = new String[numUniforms];</span>

<span class="nc bnc" id="L820" title="All 2 branches missed.">		for (int i = 0; i &lt; numUniforms; i++) {</span>
<span class="nc" id="L821">			params.clear();</span>
<span class="nc" id="L822">			params.put(0, 1);</span>
<span class="nc" id="L823">			type.clear();</span>
<span class="nc" id="L824">			String name = Gdx.gl20.glGetActiveUniform(program, i, params, type);</span>
<span class="nc" id="L825">			int location = Gdx.gl20.glGetUniformLocation(program, name);</span>
<span class="nc" id="L826">			uniforms.put(name, location);</span>
<span class="nc" id="L827">			uniformTypes.put(name, type.get(0));</span>
<span class="nc" id="L828">			uniformSizes.put(name, params.get(0));</span>
<span class="nc" id="L829">			uniformNames[i] = name;</span>
		}
<span class="nc" id="L831">	}</span>

	private void fetchAttributes () {
<span class="nc" id="L834">		params.clear();</span>
<span class="nc" id="L835">		Gdx.gl20.glGetProgramiv(program, GL20.GL_ACTIVE_ATTRIBUTES, params);</span>
<span class="nc" id="L836">		int numAttributes = params.get(0);</span>

<span class="nc" id="L838">		attributeNames = new String[numAttributes];</span>

<span class="nc bnc" id="L840" title="All 2 branches missed.">		for (int i = 0; i &lt; numAttributes; i++) {</span>
<span class="nc" id="L841">			params.clear();</span>
<span class="nc" id="L842">			params.put(0, 1);</span>
<span class="nc" id="L843">			type.clear();</span>
<span class="nc" id="L844">			String name = Gdx.gl20.glGetActiveAttrib(program, i, params, type);</span>
<span class="nc" id="L845">			int location = Gdx.gl20.glGetAttribLocation(program, name);</span>
<span class="nc" id="L846">			attributes.put(name, location);</span>
<span class="nc" id="L847">			attributeTypes.put(name, type.get(0));</span>
<span class="nc" id="L848">			attributeSizes.put(name, params.get(0));</span>
<span class="nc" id="L849">			attributeNames[i] = name;</span>
		}
<span class="nc" id="L851">	}</span>

	/** @param name the name of the attribute
	 * @return whether the attribute is available in the shader */
	public boolean hasAttribute (String name) {
<span class="nc" id="L856">		return attributes.containsKey(name);</span>
	}

	/** @param name the name of the attribute
	 * @return the type of the attribute, one of {@link GL20#GL_FLOAT}, {@link GL20#GL_FLOAT_VEC2} etc. */
	public int getAttributeType (String name) {
<span class="nc" id="L862">		return attributeTypes.get(name, 0);</span>
	}

	/** @param name the name of the attribute
	 * @return the location of the attribute or -1. */
	public int getAttributeLocation (String name) {
<span class="nc" id="L868">		return attributes.get(name, -1);</span>
	}

	/** @param name the name of the attribute
	 * @return the size of the attribute or 0. */
	public int getAttributeSize (String name) {
<span class="nc" id="L874">		return attributeSizes.get(name, 0);</span>
	}

	/** @param name the name of the uniform
	 * @return whether the uniform is available in the shader */
	public boolean hasUniform (String name) {
<span class="nc" id="L880">		return uniforms.containsKey(name);</span>
	}

	/** @param name the name of the uniform
	 * @return the type of the uniform, one of {@link GL20#GL_FLOAT}, {@link GL20#GL_FLOAT_VEC2} etc. */
	public int getUniformType (String name) {
<span class="nc" id="L886">		return uniformTypes.get(name, 0);</span>
	}

	/** @param name the name of the uniform
	 * @return the location of the uniform or -1. */
	public int getUniformLocation (String name) {
<span class="nc" id="L892">		return uniforms.get(name, -1);</span>
	}

	/** @param name the name of the uniform
	 * @return the size of the uniform or 0. */
	public int getUniformSize (String name) {
<span class="nc" id="L898">		return uniformSizes.get(name, 0);</span>
	}

	/** @return the attributes */
	public String[] getAttributes () {
<span class="nc" id="L903">		return attributeNames;</span>
	}

	/** @return the uniforms */
	public String[] getUniforms () {
<span class="nc" id="L908">		return uniformNames;</span>
	}

	/** @return the source of the vertex shader */
	public String getVertexShaderSource () {
<span class="nc" id="L913">		return vertexShaderSource;</span>
	}

	/** @return the source of the fragment shader */
	public String getFragmentShaderSource () {
<span class="nc" id="L918">		return fragmentShaderSource;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>