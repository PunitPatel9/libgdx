<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TextureAtlas.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">gdx</a> &gt; <a href="index.source.html" class="el_package">com.badlogic.gdx.graphics.g2d</a> &gt; <span class="el_source">TextureAtlas.java</span></div><h1>TextureAtlas.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2011 See AUTHORS file.
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

package com.badlogic.gdx.graphics.g2d;

import static com.badlogic.gdx.graphics.Texture.TextureWrap.*;

import com.badlogic.gdx.Files.FileType;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.Pixmap.Format;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.Texture.TextureFilter;
import com.badlogic.gdx.graphics.Texture.TextureWrap;
import com.badlogic.gdx.graphics.g2d.TextureAtlas.TextureAtlasData.Page;
import com.badlogic.gdx.graphics.g2d.TextureAtlas.TextureAtlasData.Region;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.Disposable;
import com.badlogic.gdx.utils.GdxRuntimeException;
import com.badlogic.gdx.utils.ObjectMap;
import com.badlogic.gdx.utils.ObjectSet;
import com.badlogic.gdx.utils.Sort;
import com.badlogic.gdx.utils.StreamUtils;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Set;

/** Loads images from texture atlases created by TexturePacker.&lt;br&gt;
 * &lt;br&gt;
 * A TextureAtlas must be disposed to free up the resources consumed by the backing textures.
 * @author Nathan Sweet */
public class TextureAtlas implements Disposable {
<span class="nc" id="L50">	static final String[] tuple = new String[4];</span>

<span class="nc" id="L52">	private final ObjectSet&lt;Texture&gt; textures = new ObjectSet(4);</span>
<span class="nc" id="L53">	private final Array&lt;AtlasRegion&gt; regions = new Array();</span>

	public static class TextureAtlasData {
		public static class Page {
			public final FileHandle textureFile;
			public Texture texture;
			public final float width, height;
			public final boolean useMipMaps;
			public final Format format;
			public final TextureFilter minFilter;
			public final TextureFilter magFilter;
			public final TextureWrap uWrap;
			public final TextureWrap vWrap;

			public Page (FileHandle handle, float width, float height, boolean useMipMaps, Format format, TextureFilter minFilter,
<span class="nc" id="L68">				TextureFilter magFilter, TextureWrap uWrap, TextureWrap vWrap) {</span>
<span class="nc" id="L69">				this.width = width;</span>
<span class="nc" id="L70">				this.height = height;</span>
<span class="nc" id="L71">				this.textureFile = handle;</span>
<span class="nc" id="L72">				this.useMipMaps = useMipMaps;</span>
<span class="nc" id="L73">				this.format = format;</span>
<span class="nc" id="L74">				this.minFilter = minFilter;</span>
<span class="nc" id="L75">				this.magFilter = magFilter;</span>
<span class="nc" id="L76">				this.uWrap = uWrap;</span>
<span class="nc" id="L77">				this.vWrap = vWrap;</span>
<span class="nc" id="L78">			}</span>
		}

<span class="nc" id="L81">		public static class Region {</span>
			public Page page;
			public int index;
			public String name;
			public float offsetX;
			public float offsetY;
			public int originalWidth;
			public int originalHeight;
			public boolean rotate;
			public int degrees;
			public int left;
			public int top;
			public int width;
			public int height;
			public boolean flip;
			public int[] splits;
			public int[] pads;
		}

<span class="nc" id="L100">		final Array&lt;Page&gt; pages = new Array();</span>
<span class="nc" id="L101">		final Array&lt;Region&gt; regions = new Array();</span>

<span class="nc" id="L103">		public TextureAtlasData (FileHandle packFile, FileHandle imagesDir, boolean flip) {</span>
<span class="nc" id="L104">			BufferedReader reader = new BufferedReader(new InputStreamReader(packFile.read()), 64);</span>
			try {
<span class="nc" id="L106">				Page pageImage = null;</span>
				while (true) {
<span class="nc" id="L108">					String line = reader.readLine();</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">					if (line == null) break;</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">					if (line.trim().length() == 0)</span>
<span class="nc" id="L111">						pageImage = null;</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">					else if (pageImage == null) {</span>
<span class="nc" id="L113">						FileHandle file = imagesDir.child(line);</span>

<span class="nc" id="L115">						float width = 0, height = 0;</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">						if (readTuple(reader) == 2) { // size is only optional for an atlas packed with an old TexturePacker.</span>
<span class="nc" id="L117">							width = Integer.parseInt(tuple[0]);</span>
<span class="nc" id="L118">							height = Integer.parseInt(tuple[1]);</span>
<span class="nc" id="L119">							readTuple(reader);</span>
						}
<span class="nc" id="L121">						Format format = Format.valueOf(tuple[0]);</span>

<span class="nc" id="L123">						readTuple(reader);</span>
<span class="nc" id="L124">						TextureFilter min = TextureFilter.valueOf(tuple[0]);</span>
<span class="nc" id="L125">						TextureFilter max = TextureFilter.valueOf(tuple[1]);</span>

<span class="nc" id="L127">						String direction = readValue(reader);</span>
<span class="nc" id="L128">						TextureWrap repeatX = ClampToEdge;</span>
<span class="nc" id="L129">						TextureWrap repeatY = ClampToEdge;</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">						if (direction.equals(&quot;x&quot;))</span>
<span class="nc" id="L131">							repeatX = Repeat;</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">						else if (direction.equals(&quot;y&quot;))</span>
<span class="nc" id="L133">							repeatY = Repeat;</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">						else if (direction.equals(&quot;xy&quot;)) {</span>
<span class="nc" id="L135">							repeatX = Repeat;</span>
<span class="nc" id="L136">							repeatY = Repeat;</span>
						}

<span class="nc" id="L139">						pageImage = new Page(file, width, height, min.isMipMap(), format, min, max, repeatX, repeatY);</span>
<span class="nc" id="L140">						pages.add(pageImage);</span>
<span class="nc" id="L141">					} else {</span>
<span class="nc" id="L142">						String rotateValue = readValue(reader);</span>
						int degrees;
<span class="nc bnc" id="L144" title="All 2 branches missed.">						if (rotateValue.equalsIgnoreCase(&quot;true&quot;))</span>
<span class="nc" id="L145">							degrees = 90;</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">						else if (rotateValue.equalsIgnoreCase(&quot;false&quot;))</span>
<span class="nc" id="L147">							degrees = 0;</span>
						else
<span class="nc" id="L149">							degrees = Integer.valueOf(rotateValue);</span>

<span class="nc" id="L151">						readTuple(reader);</span>
<span class="nc" id="L152">						int left = Integer.parseInt(tuple[0]);</span>
<span class="nc" id="L153">						int top = Integer.parseInt(tuple[1]);</span>

<span class="nc" id="L155">						readTuple(reader);</span>
<span class="nc" id="L156">						int width = Integer.parseInt(tuple[0]);</span>
<span class="nc" id="L157">						int height = Integer.parseInt(tuple[1]);</span>

<span class="nc" id="L159">						Region region = new Region();</span>
<span class="nc" id="L160">						region.page = pageImage;</span>
<span class="nc" id="L161">						region.left = left;</span>
<span class="nc" id="L162">						region.top = top;</span>
<span class="nc" id="L163">						region.width = width;</span>
<span class="nc" id="L164">						region.height = height;</span>
<span class="nc" id="L165">						region.name = line;</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">						region.rotate = degrees == 90;</span>
<span class="nc" id="L167">						region.degrees = degrees;</span>

<span class="nc bnc" id="L169" title="All 2 branches missed.">						if (readTuple(reader) == 4) { // split is optional</span>
<span class="nc" id="L170">							region.splits = new int[] {Integer.parseInt(tuple[0]), Integer.parseInt(tuple[1]),</span>
<span class="nc" id="L171">								Integer.parseInt(tuple[2]), Integer.parseInt(tuple[3])};</span>

<span class="nc bnc" id="L173" title="All 2 branches missed.">							if (readTuple(reader) == 4) { // pad is optional, but only present with splits</span>
<span class="nc" id="L174">								region.pads = new int[] {Integer.parseInt(tuple[0]), Integer.parseInt(tuple[1]),</span>
<span class="nc" id="L175">									Integer.parseInt(tuple[2]), Integer.parseInt(tuple[3])};</span>

<span class="nc" id="L177">								readTuple(reader);</span>
							}
						}

<span class="nc" id="L181">						region.originalWidth = Integer.parseInt(tuple[0]);</span>
<span class="nc" id="L182">						region.originalHeight = Integer.parseInt(tuple[1]);</span>

<span class="nc" id="L184">						readTuple(reader);</span>
<span class="nc" id="L185">						region.offsetX = Integer.parseInt(tuple[0]);</span>
<span class="nc" id="L186">						region.offsetY = Integer.parseInt(tuple[1]);</span>

<span class="nc" id="L188">						region.index = Integer.parseInt(readValue(reader));</span>

<span class="nc bnc" id="L190" title="All 2 branches missed.">						if (flip) region.flip = true;</span>

<span class="nc" id="L192">						regions.add(region);</span>
					}
<span class="nc" id="L194">				}</span>
<span class="nc" id="L195">			} catch (Exception ex) {</span>
<span class="nc" id="L196">				throw new GdxRuntimeException(&quot;Error reading pack file: &quot; + packFile, ex);</span>
			} finally {
<span class="nc" id="L198">				StreamUtils.closeQuietly(reader);</span>
			}

<span class="nc" id="L201">			regions.sort(indexComparator);</span>
<span class="nc" id="L202">		}</span>

		public Array&lt;Page&gt; getPages () {
<span class="nc" id="L205">			return pages;</span>
		}

		public Array&lt;Region&gt; getRegions () {
<span class="nc" id="L209">			return regions;</span>
		}
	}

	/** Creates an empty atlas to which regions can be added. */
<span class="nc" id="L214">	public TextureAtlas () {</span>
<span class="nc" id="L215">	}</span>

	/** Loads the specified pack file using {@link FileType#Internal}, using the parent directory of the pack file to find the page
	 * images. */
	public TextureAtlas (String internalPackFile) {
<span class="nc" id="L220">		this(Gdx.files.internal(internalPackFile));</span>
<span class="nc" id="L221">	}</span>

	/** Loads the specified pack file, using the parent directory of the pack file to find the page images. */
	public TextureAtlas (FileHandle packFile) {
<span class="nc" id="L225">		this(packFile, packFile.parent());</span>
<span class="nc" id="L226">	}</span>

	/** @param flip If true, all regions loaded will be flipped for use with a perspective where 0,0 is the upper left corner.
	 * @see #TextureAtlas(FileHandle) */
	public TextureAtlas (FileHandle packFile, boolean flip) {
<span class="nc" id="L231">		this(packFile, packFile.parent(), flip);</span>
<span class="nc" id="L232">	}</span>

	public TextureAtlas (FileHandle packFile, FileHandle imagesDir) {
<span class="nc" id="L235">		this(packFile, imagesDir, false);</span>
<span class="nc" id="L236">	}</span>

	/** @param flip If true, all regions loaded will be flipped for use with a perspective where 0,0 is the upper left corner. */
	public TextureAtlas (FileHandle packFile, FileHandle imagesDir, boolean flip) {
<span class="nc" id="L240">		this(new TextureAtlasData(packFile, imagesDir, flip));</span>
<span class="nc" id="L241">	}</span>

	/** @param data May be null. */
<span class="nc" id="L244">	public TextureAtlas (TextureAtlasData data) {</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">		if (data != null) load(data);</span>
<span class="nc" id="L246">	}</span>

	private void load (TextureAtlasData data) {
<span class="nc" id="L249">		ObjectMap&lt;Page, Texture&gt; pageToTexture = new ObjectMap&lt;Page, Texture&gt;();</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">		for (Page page : data.pages) {</span>
<span class="nc" id="L251">			Texture texture = null;</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">			if (page.texture == null) {</span>
<span class="nc" id="L253">				texture = new Texture(page.textureFile, page.format, page.useMipMaps);</span>
<span class="nc" id="L254">				texture.setFilter(page.minFilter, page.magFilter);</span>
<span class="nc" id="L255">				texture.setWrap(page.uWrap, page.vWrap);</span>
			} else {
<span class="nc" id="L257">				texture = page.texture;</span>
<span class="nc" id="L258">				texture.setFilter(page.minFilter, page.magFilter);</span>
<span class="nc" id="L259">				texture.setWrap(page.uWrap, page.vWrap);</span>
			}
<span class="nc" id="L261">			textures.add(texture);</span>
<span class="nc" id="L262">			pageToTexture.put(page, texture);</span>
<span class="nc" id="L263">		}</span>

<span class="nc bnc" id="L265" title="All 2 branches missed.">		for (Region region : data.regions) {</span>
<span class="nc" id="L266">			int width = region.width;</span>
<span class="nc" id="L267">			int height = region.height;</span>
<span class="nc" id="L268">			AtlasRegion atlasRegion = new AtlasRegion(pageToTexture.get(region.page), region.left, region.top,</span>
<span class="nc bnc" id="L269" title="All 4 branches missed.">				region.rotate ? height : width, region.rotate ? width : height);</span>
<span class="nc" id="L270">			atlasRegion.index = region.index;</span>
<span class="nc" id="L271">			atlasRegion.name = region.name;</span>
<span class="nc" id="L272">			atlasRegion.offsetX = region.offsetX;</span>
<span class="nc" id="L273">			atlasRegion.offsetY = region.offsetY;</span>
<span class="nc" id="L274">			atlasRegion.originalHeight = region.originalHeight;</span>
<span class="nc" id="L275">			atlasRegion.originalWidth = region.originalWidth;</span>
<span class="nc" id="L276">			atlasRegion.rotate = region.rotate;</span>
<span class="nc" id="L277">			atlasRegion.degrees = region.degrees;</span>
<span class="nc" id="L278">			atlasRegion.splits = region.splits;</span>
<span class="nc" id="L279">			atlasRegion.pads = region.pads;</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">			if (region.flip) atlasRegion.flip(false, true);</span>
<span class="nc" id="L281">			regions.add(atlasRegion);</span>
<span class="nc" id="L282">		}</span>
<span class="nc" id="L283">	}</span>

	/** Adds a region to the atlas. The specified texture will be disposed when the atlas is disposed. */
	public AtlasRegion addRegion (String name, Texture texture, int x, int y, int width, int height) {
<span class="nc" id="L287">		textures.add(texture);</span>
<span class="nc" id="L288">		AtlasRegion region = new AtlasRegion(texture, x, y, width, height);</span>
<span class="nc" id="L289">		region.name = name;</span>
<span class="nc" id="L290">		region.index = -1;</span>
<span class="nc" id="L291">		regions.add(region);</span>
<span class="nc" id="L292">		return region;</span>
	}

	/** Adds a region to the atlas. The texture for the specified region will be disposed when the atlas is disposed. */
	public AtlasRegion addRegion (String name, TextureRegion textureRegion) {
<span class="nc" id="L297">		textures.add(textureRegion.texture);</span>
<span class="nc" id="L298">		AtlasRegion region = new AtlasRegion(textureRegion);</span>
<span class="nc" id="L299">		region.name = name;</span>
<span class="nc" id="L300">		region.index = -1;</span>
<span class="nc" id="L301">		regions.add(region);</span>
<span class="nc" id="L302">		return region;</span>
	}

	/** Returns all regions in the atlas. */
	public Array&lt;AtlasRegion&gt; getRegions () {
<span class="nc" id="L307">		return regions;</span>
	}

	/** Returns the first region found with the specified name. This method uses string comparison to find the region, so the result
	 * should be cached rather than calling this method multiple times.
	 * @return The region, or null. */
	public AtlasRegion findRegion (String name) {
<span class="nc bnc" id="L314" title="All 2 branches missed.">		for (int i = 0, n = regions.size; i &lt; n; i++)</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">			if (regions.get(i).name.equals(name)) return regions.get(i);</span>
<span class="nc" id="L316">		return null;</span>
	}

	/** Returns the first region found with the specified name and index. This method uses string comparison to find the region, so
	 * the result should be cached rather than calling this method multiple times.
	 * @return The region, or null. */
	public AtlasRegion findRegion (String name, int index) {
<span class="nc bnc" id="L323" title="All 2 branches missed.">		for (int i = 0, n = regions.size; i &lt; n; i++) {</span>
<span class="nc" id="L324">			AtlasRegion region = regions.get(i);</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">			if (!region.name.equals(name)) continue;</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">			if (region.index != index) continue;</span>
<span class="nc" id="L327">			return region;</span>
		}
<span class="nc" id="L329">		return null;</span>
	}

	/** Returns all regions with the specified name, ordered by smallest to largest {@link AtlasRegion#index index}. This method
	 * uses string comparison to find the regions, so the result should be cached rather than calling this method multiple times. */
	public Array&lt;AtlasRegion&gt; findRegions (String name) {
<span class="nc" id="L335">		Array&lt;AtlasRegion&gt; matched = new Array(AtlasRegion.class);</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">		for (int i = 0, n = regions.size; i &lt; n; i++) {</span>
<span class="nc" id="L337">			AtlasRegion region = regions.get(i);</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">			if (region.name.equals(name)) matched.add(new AtlasRegion(region));</span>
		}
<span class="nc" id="L340">		return matched;</span>
	}

	/** Returns all regions in the atlas as sprites. This method creates a new sprite for each region, so the result should be
	 * stored rather than calling this method multiple times.
	 * @see #createSprite(String) */
	public Array&lt;Sprite&gt; createSprites () {
<span class="nc" id="L347">		Array sprites = new Array(true, regions.size, Sprite.class);</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">		for (int i = 0, n = regions.size; i &lt; n; i++)</span>
<span class="nc" id="L349">			sprites.add(newSprite(regions.get(i)));</span>
<span class="nc" id="L350">		return sprites;</span>
	}

	/** Returns the first region found with the specified name as a sprite. If whitespace was stripped from the region when it was
	 * packed, the sprite is automatically positioned as if whitespace had not been stripped. This method uses string comparison to
	 * find the region and constructs a new sprite, so the result should be cached rather than calling this method multiple times.
	 * @return The sprite, or null. */
	public Sprite createSprite (String name) {
<span class="nc bnc" id="L358" title="All 2 branches missed.">		for (int i = 0, n = regions.size; i &lt; n; i++)</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">			if (regions.get(i).name.equals(name)) return newSprite(regions.get(i));</span>
<span class="nc" id="L360">		return null;</span>
	}

	/** Returns the first region found with the specified name and index as a sprite. This method uses string comparison to find the
	 * region and constructs a new sprite, so the result should be cached rather than calling this method multiple times.
	 * @return The sprite, or null.
	 * @see #createSprite(String) */
	public Sprite createSprite (String name, int index) {
<span class="nc bnc" id="L368" title="All 2 branches missed.">		for (int i = 0, n = regions.size; i &lt; n; i++) {</span>
<span class="nc" id="L369">			AtlasRegion region = regions.get(i);</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">			if (!region.name.equals(name)) continue;</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">			if (region.index != index) continue;</span>
<span class="nc" id="L372">			return newSprite(regions.get(i));</span>
		}
<span class="nc" id="L374">		return null;</span>
	}

	/** Returns all regions with the specified name as sprites, ordered by smallest to largest {@link AtlasRegion#index index}. This
	 * method uses string comparison to find the regions and constructs new sprites, so the result should be cached rather than
	 * calling this method multiple times.
	 * @see #createSprite(String) */
	public Array&lt;Sprite&gt; createSprites (String name) {
<span class="nc" id="L382">		Array&lt;Sprite&gt; matched = new Array(Sprite.class);</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">		for (int i = 0, n = regions.size; i &lt; n; i++) {</span>
<span class="nc" id="L384">			AtlasRegion region = regions.get(i);</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">			if (region.name.equals(name)) matched.add(newSprite(region));</span>
		}
<span class="nc" id="L387">		return matched;</span>
	}

	private Sprite newSprite (AtlasRegion region) {
<span class="nc bnc" id="L391" title="All 4 branches missed.">		if (region.packedWidth == region.originalWidth &amp;&amp; region.packedHeight == region.originalHeight) {</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">			if (region.rotate) {</span>
<span class="nc" id="L393">				Sprite sprite = new Sprite(region);</span>
<span class="nc" id="L394">				sprite.setBounds(0, 0, region.getRegionHeight(), region.getRegionWidth());</span>
<span class="nc" id="L395">				sprite.rotate90(true);</span>
<span class="nc" id="L396">				return sprite;</span>
			}
<span class="nc" id="L398">			return new Sprite(region);</span>
		}
<span class="nc" id="L400">		return new AtlasSprite(region);</span>
	}

	/** Returns the first region found with the specified name as a {@link NinePatch}. The region must have been packed with
	 * ninepatch splits. This method uses string comparison to find the region and constructs a new ninepatch, so the result should
	 * be cached rather than calling this method multiple times.
	 * @return The ninepatch, or null. */
	public NinePatch createPatch (String name) {
<span class="nc bnc" id="L408" title="All 2 branches missed.">		for (int i = 0, n = regions.size; i &lt; n; i++) {</span>
<span class="nc" id="L409">			AtlasRegion region = regions.get(i);</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">			if (region.name.equals(name)) {</span>
<span class="nc" id="L411">				int[] splits = region.splits;</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">				if (splits == null) throw new IllegalArgumentException(&quot;Region does not have ninepatch splits: &quot; + name);</span>
<span class="nc" id="L413">				NinePatch patch = new NinePatch(region, splits[0], splits[1], splits[2], splits[3]);</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">				if (region.pads != null) patch.setPadding(region.pads[0], region.pads[1], region.pads[2], region.pads[3]);</span>
<span class="nc" id="L415">				return patch;</span>
			}
		}
<span class="nc" id="L418">		return null;</span>
	}

	/** @return the textures of the pages, unordered */
	public ObjectSet&lt;Texture&gt; getTextures () {
<span class="nc" id="L423">		return textures;</span>
	}

	/** Releases all resources associated with this TextureAtlas instance. This releases all the textures backing all TextureRegions
	 * and Sprites, which should no longer be used after calling dispose. */
	public void dispose () {
<span class="nc bnc" id="L429" title="All 2 branches missed.">		for (Texture texture : textures)</span>
<span class="nc" id="L430">			texture.dispose();</span>
<span class="nc" id="L431">		textures.clear(0);</span>
<span class="nc" id="L432">	}</span>

<span class="nc" id="L434">	static final Comparator&lt;Region&gt; indexComparator = new Comparator&lt;Region&gt;() {</span>
		public int compare (Region region1, Region region2) {
<span class="nc" id="L436">			int i1 = region1.index;</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">			if (i1 == -1) i1 = Integer.MAX_VALUE;</span>
<span class="nc" id="L438">			int i2 = region2.index;</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">			if (i2 == -1) i2 = Integer.MAX_VALUE;</span>
<span class="nc" id="L440">			return i1 - i2;</span>
		}
	};

	static String readValue (BufferedReader reader) throws IOException {
<span class="nc" id="L445">		String line = reader.readLine();</span>
<span class="nc" id="L446">		int colon = line.indexOf(':');</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">		if (colon == -1) throw new GdxRuntimeException(&quot;Invalid line: &quot; + line);</span>
<span class="nc" id="L448">		return line.substring(colon + 1).trim();</span>
	}

	/** Returns the number of tuple values read (1, 2 or 4). */
	static int readTuple (BufferedReader reader) throws IOException {
<span class="nc" id="L453">		String line = reader.readLine();</span>
<span class="nc" id="L454">		int colon = line.indexOf(':');</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">		if (colon == -1) throw new GdxRuntimeException(&quot;Invalid line: &quot; + line);</span>
<span class="nc" id="L456">		int i = 0, lastMatch = colon + 1;</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">		for (i = 0; i &lt; 3; i++) {</span>
<span class="nc" id="L458">			int comma = line.indexOf(',', lastMatch);</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">			if (comma == -1) break;</span>
<span class="nc" id="L460">			tuple[i] = line.substring(lastMatch, comma).trim();</span>
<span class="nc" id="L461">			lastMatch = comma + 1;</span>
		}
<span class="nc" id="L463">		tuple[i] = line.substring(lastMatch).trim();</span>
<span class="nc" id="L464">		return i + 1;</span>
	}

	/** Describes the region of a packed image and provides information about the original image before it was packed. */
	static public class AtlasRegion extends TextureRegion {
		/** The number at the end of the original image file name, or -1 if none.&lt;br&gt;
		 * &lt;br&gt;
		 * When sprites are packed, if the original file name ends with a number, it is stored as the index and is not considered as
		 * part of the sprite's name. This is useful for keeping animation frames in order.
		 * @see TextureAtlas#findRegions(String) */
		public int index;

		/** The name of the original image file, without the file's extension.&lt;br&gt;
		 * If the name ends with an underscore followed by only numbers, that part is excluded: 
		 * underscores denote special instructions to the texture packer. */
		public String name;

		/** The offset from the left of the original image to the left of the packed image, after whitespace was removed for packing. */
		public float offsetX;

		/** The offset from the bottom of the original image to the bottom of the packed image, after whitespace was removed for
		 * packing. */
		public float offsetY;

		/** The width of the image, after whitespace was removed for packing. */
		public int packedWidth;

		/** The height of the image, after whitespace was removed for packing. */
		public int packedHeight;

		/** The width of the image, before whitespace was removed and rotation was applied for packing. */
		public int originalWidth;

		/** The height of the image, before whitespace was removed for packing. */
		public int originalHeight;

		/** If true, the region has been rotated 90 degrees counter clockwise. */
		public boolean rotate;

		/** The degrees the region has been rotated, counter clockwise between 0 and 359. Most atlas region handling deals only with
		 * 0 or 90 degree rotation (enough to handle rectangles). More advanced texture packing may support other rotations (eg, for
		 * tightly packing polygons). */
		public int degrees;

		/** The ninepatch splits, or null if not a ninepatch. Has 4 elements: left, right, top, bottom. */
		public int[] splits;

		/** The ninepatch pads, or null if not a ninepatch or the has no padding. Has 4 elements: left, right, top, bottom. */
		public int[] pads;

		public AtlasRegion (Texture texture, int x, int y, int width, int height) {
<span class="nc" id="L515">			super(texture, x, y, width, height);</span>
<span class="nc" id="L516">			originalWidth = width;</span>
<span class="nc" id="L517">			originalHeight = height;</span>
<span class="nc" id="L518">			packedWidth = width;</span>
<span class="nc" id="L519">			packedHeight = height;</span>
<span class="nc" id="L520">		}</span>

<span class="nc" id="L522">		public AtlasRegion (AtlasRegion region) {</span>
<span class="nc" id="L523">			setRegion(region);</span>
<span class="nc" id="L524">			index = region.index;</span>
<span class="nc" id="L525">			name = region.name;</span>
<span class="nc" id="L526">			offsetX = region.offsetX;</span>
<span class="nc" id="L527">			offsetY = region.offsetY;</span>
<span class="nc" id="L528">			packedWidth = region.packedWidth;</span>
<span class="nc" id="L529">			packedHeight = region.packedHeight;</span>
<span class="nc" id="L530">			originalWidth = region.originalWidth;</span>
<span class="nc" id="L531">			originalHeight = region.originalHeight;</span>
<span class="nc" id="L532">			rotate = region.rotate;</span>
<span class="nc" id="L533">			degrees = region.degrees;</span>
<span class="nc" id="L534">			splits = region.splits;</span>
<span class="nc" id="L535">		}</span>

<span class="nc" id="L537">		public AtlasRegion (TextureRegion region) {</span>
<span class="nc" id="L538">			setRegion(region);</span>
<span class="nc" id="L539">			packedWidth = region.getRegionWidth();</span>
<span class="nc" id="L540">			packedHeight = region.getRegionHeight();</span>
<span class="nc" id="L541">			originalWidth = packedWidth;</span>
<span class="nc" id="L542">			originalHeight = packedHeight;</span>
<span class="nc" id="L543">		}</span>

		@Override
		/** Flips the region, adjusting the offset so the image appears to be flip as if no whitespace has been removed for packing. */
		public void flip (boolean x, boolean y) {
<span class="nc" id="L548">			super.flip(x, y);</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">			if (x) offsetX = originalWidth - offsetX - getRotatedPackedWidth();</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">			if (y) offsetY = originalHeight - offsetY - getRotatedPackedHeight();</span>
<span class="nc" id="L551">		}</span>

		/** Returns the packed width considering the {@link #rotate} value, if it is true then it returns the packedHeight,
		 * otherwise it returns the packedWidth. */
		public float getRotatedPackedWidth () {
<span class="nc bnc" id="L556" title="All 2 branches missed.">			return rotate ? packedHeight : packedWidth;</span>
		}

		/** Returns the packed height considering the {@link #rotate} value, if it is true then it returns the packedWidth,
		 * otherwise it returns the packedHeight. */
		public float getRotatedPackedHeight () {
<span class="nc bnc" id="L562" title="All 2 branches missed.">			return rotate ? packedWidth : packedHeight;</span>
		}

		public String toString () {
<span class="nc" id="L566">			return name;</span>
		}
	}

	/** A sprite that, if whitespace was stripped from the region when it was packed, is automatically positioned as if whitespace
	 * had not been stripped. */
	static public class AtlasSprite extends Sprite {
		final AtlasRegion region;
		float originalOffsetX, originalOffsetY;

<span class="nc" id="L576">		public AtlasSprite (AtlasRegion region) {</span>
<span class="nc" id="L577">			this.region = new AtlasRegion(region);</span>
<span class="nc" id="L578">			originalOffsetX = region.offsetX;</span>
<span class="nc" id="L579">			originalOffsetY = region.offsetY;</span>
<span class="nc" id="L580">			setRegion(region);</span>
<span class="nc" id="L581">			setOrigin(region.originalWidth / 2f, region.originalHeight / 2f);</span>
<span class="nc" id="L582">			int width = region.getRegionWidth();</span>
<span class="nc" id="L583">			int height = region.getRegionHeight();</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">			if (region.rotate) {</span>
<span class="nc" id="L585">				super.rotate90(true);</span>
<span class="nc" id="L586">				super.setBounds(region.offsetX, region.offsetY, height, width);</span>
			} else
<span class="nc" id="L588">				super.setBounds(region.offsetX, region.offsetY, width, height);</span>
<span class="nc" id="L589">			setColor(1, 1, 1, 1);</span>
<span class="nc" id="L590">		}</span>

<span class="nc" id="L592">		public AtlasSprite (AtlasSprite sprite) {</span>
<span class="nc" id="L593">			region = sprite.region;</span>
<span class="nc" id="L594">			this.originalOffsetX = sprite.originalOffsetX;</span>
<span class="nc" id="L595">			this.originalOffsetY = sprite.originalOffsetY;</span>
<span class="nc" id="L596">			set(sprite);</span>
<span class="nc" id="L597">		}</span>

		@Override
		public void setPosition (float x, float y) {
<span class="nc" id="L601">			super.setPosition(x + region.offsetX, y + region.offsetY);</span>
<span class="nc" id="L602">		}</span>

		@Override
		public void setX (float x) {
<span class="nc" id="L606">			super.setX(x + region.offsetX);</span>
<span class="nc" id="L607">		}</span>

		@Override
		public void setY (float y) {
<span class="nc" id="L611">			super.setY(y + region.offsetY);</span>
<span class="nc" id="L612">		}</span>

		@Override
		public void setBounds (float x, float y, float width, float height) {
<span class="nc" id="L616">			float widthRatio = width / region.originalWidth;</span>
<span class="nc" id="L617">			float heightRatio = height / region.originalHeight;</span>
<span class="nc" id="L618">			region.offsetX = originalOffsetX * widthRatio;</span>
<span class="nc" id="L619">			region.offsetY = originalOffsetY * heightRatio;</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">			int packedWidth = region.rotate ? region.packedHeight : region.packedWidth;</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">			int packedHeight = region.rotate ? region.packedWidth : region.packedHeight;</span>
<span class="nc" id="L622">			super.setBounds(x + region.offsetX, y + region.offsetY, packedWidth * widthRatio, packedHeight * heightRatio);</span>
<span class="nc" id="L623">		}</span>

		@Override
		public void setSize (float width, float height) {
<span class="nc" id="L627">			setBounds(getX(), getY(), width, height);</span>
<span class="nc" id="L628">		}</span>

		@Override
		public void setOrigin (float originX, float originY) {
<span class="nc" id="L632">			super.setOrigin(originX - region.offsetX, originY - region.offsetY);</span>
<span class="nc" id="L633">		}</span>

		@Override
		public void setOriginCenter () {
<span class="nc" id="L637">			super.setOrigin(width / 2 - region.offsetX, height / 2 - region.offsetY);</span>
<span class="nc" id="L638">		}</span>

		@Override
		public void flip (boolean x, boolean y) {
			// Flip texture.
<span class="nc bnc" id="L643" title="All 2 branches missed.">			if (region.rotate)</span>
<span class="nc" id="L644">				super.flip(y, x);</span>
			else
<span class="nc" id="L646">				super.flip(x, y);</span>

<span class="nc" id="L648">			float oldOriginX = getOriginX();</span>
<span class="nc" id="L649">			float oldOriginY = getOriginY();</span>
<span class="nc" id="L650">			float oldOffsetX = region.offsetX;</span>
<span class="nc" id="L651">			float oldOffsetY = region.offsetY;</span>

<span class="nc" id="L653">			float widthRatio = getWidthRatio();</span>
<span class="nc" id="L654">			float heightRatio = getHeightRatio();</span>

<span class="nc" id="L656">			region.offsetX = originalOffsetX;</span>
<span class="nc" id="L657">			region.offsetY = originalOffsetY;</span>
<span class="nc" id="L658">			region.flip(x, y); // Updates x and y offsets.</span>
<span class="nc" id="L659">			originalOffsetX = region.offsetX;</span>
<span class="nc" id="L660">			originalOffsetY = region.offsetY;</span>
<span class="nc" id="L661">			region.offsetX *= widthRatio;</span>
<span class="nc" id="L662">			region.offsetY *= heightRatio;</span>

			// Update position and origin with new offsets.
<span class="nc" id="L665">			translate(region.offsetX - oldOffsetX, region.offsetY - oldOffsetY);</span>
<span class="nc" id="L666">			setOrigin(oldOriginX, oldOriginY);</span>
<span class="nc" id="L667">		}</span>

		@Override
		public void rotate90 (boolean clockwise) {
			// Rotate texture.
<span class="nc" id="L672">			super.rotate90(clockwise);</span>

<span class="nc" id="L674">			float oldOriginX = getOriginX();</span>
<span class="nc" id="L675">			float oldOriginY = getOriginY();</span>
<span class="nc" id="L676">			float oldOffsetX = region.offsetX;</span>
<span class="nc" id="L677">			float oldOffsetY = region.offsetY;</span>

<span class="nc" id="L679">			float widthRatio = getWidthRatio();</span>
<span class="nc" id="L680">			float heightRatio = getHeightRatio();</span>

<span class="nc bnc" id="L682" title="All 2 branches missed.">			if (clockwise) {</span>
<span class="nc" id="L683">				region.offsetX = oldOffsetY;</span>
<span class="nc" id="L684">				region.offsetY = region.originalHeight * heightRatio - oldOffsetX - region.packedWidth * widthRatio;</span>
			} else {
<span class="nc" id="L686">				region.offsetX = region.originalWidth * widthRatio - oldOffsetY - region.packedHeight * heightRatio;</span>
<span class="nc" id="L687">				region.offsetY = oldOffsetX;</span>
			}

			// Update position and origin with new offsets.
<span class="nc" id="L691">			translate(region.offsetX - oldOffsetX, region.offsetY - oldOffsetY);</span>
<span class="nc" id="L692">			setOrigin(oldOriginX, oldOriginY);</span>
<span class="nc" id="L693">		}</span>

		@Override
		public float getX () {
<span class="nc" id="L697">			return super.getX() - region.offsetX;</span>
		}

		@Override
		public float getY () {
<span class="nc" id="L702">			return super.getY() - region.offsetY;</span>
		}

		@Override
		public float getOriginX () {
<span class="nc" id="L707">			return super.getOriginX() + region.offsetX;</span>
		}

		@Override
		public float getOriginY () {
<span class="nc" id="L712">			return super.getOriginY() + region.offsetY;</span>
		}

		@Override
		public float getWidth () {
<span class="nc" id="L717">			return super.getWidth() / region.getRotatedPackedWidth() * region.originalWidth;</span>
		}

		@Override
		public float getHeight () {
<span class="nc" id="L722">			return super.getHeight() / region.getRotatedPackedHeight() * region.originalHeight;</span>
		}

		public float getWidthRatio () {
<span class="nc" id="L726">			return super.getWidth() / region.getRotatedPackedWidth();</span>
		}

		public float getHeightRatio () {
<span class="nc" id="L730">			return super.getHeight() / region.getRotatedPackedHeight();</span>
		}

		public AtlasRegion getAtlasRegion () {
<span class="nc" id="L734">			return region;</span>
		}

		public String toString () {
<span class="nc" id="L738">			return region.toString();</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>